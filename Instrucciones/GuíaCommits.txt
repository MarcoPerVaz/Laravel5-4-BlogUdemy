Commit - Creación del proyecto Laravel5-4_BlogUdemy
  -composer create-project --prefer-dist laravel/laravel Laravel5-4_BlogUdemy "5.4.*"
Commit - Se crea la carpeta Instrucciones
  -Se crea el archivo Instalación.txt
  -Se crea el archivo GuíaCommits.txt
Commit - Integrando la plantilla Zendero al proyecto Laravel5-4_BlogUdemy
  -Se copian las carpetas css, img y js de la carpeta descargada(Zendero) y se pegan en public/ del proyecto Laravel5-4_BlogUdemy
  -Se copia el contenido del archivo index.html de la carpeta descargada(Zendero) y se pega en la vista welcome.blade.php
  -Se edita la vista welcome quitando las partes que se usarán en todas las vistas y se pasa a la vista layout.blade.php
    -Se usan las directivas (@extends y @section) para vincular la vista con layout.blade.php
  -Se crea la vista layout.blade.php
    -Esta vista tendrá todo lo que se repite(head, header y footer) y las demás vistas solo agregarán el contenido del post
    -Se edita la vista layout usando la directiva (yield) para vincular con la directiva section
Commit - Creando la tabla posts y BD
  -Se modifica el archivo .env
    APP_URL=https://laravel5-4_blogudemy.it/
    DB_DATABASE=laravel54blogudemy
    DB_USERNAME=root
    DB_PASSWORD=
    -La base de datos se creó desde consola
      -se usa el comando mysql -uroot
      -CREATE DATABASE laravel54blogudemy;
  -Se usa el comando php artisan migrate
  -Error si se usa MariaDB : Specified key was too long; max key length es 767 bytes
    -Solución: Ir a app/Providers/appServiceProvider.php
      -En la función boot agregar:
        -Schema::defaultStringLength(191);
        Nota: Importar el Facade 
          -use Illuminate\Support\Facades\Schema;
    Nota: Solo si hubo el error se vuelve a usar el comando php artisan migrate
  -Se usa el comando php artisan make:model Post -m para crear un modelo con su migración
    -Dónde Post es el nombre del modelo, m es migración
  -Se edita la migración create_posts_table agregando los campos
    $table->string('title');
    $table->mediumText('excerpt');
    $table->text('body');
    $table->timestamp('published_at')->nullable();
  -Se usa el comando php artisan migrate
Commit - Mostrando los posts desde la BD
  -Se crean 2 campos manualmente en la tabla Posts en la BD
    -Mi primer post -- Extracto de mi primer post -- <p>Contenido de mi primer post</p>
  -Se crea una ruta de prueba en web.php
  -Se edita la ruta por defecto en web.php
  -Se edita la vista welcome.blade.php para mostrar los Posts que fueron agregados manualmente
    Nota: Se dejaron entre comentarios los posts que no se usan todavía
    -Se edita el post con la clase post no-image
      -Se usa la directiva @foreach ($posts as $post) para mostrar todos los posts
Commit - Mostrando la fecha de publicación de los posts
   -Se edita el modelo Post agregando
    -protected $dates = ['published_at']; para decir que el campo published_at también sea una instancia de carbon la librería
  -Se edita la vista welcome para mostrar la fecha
    <span class="c-gray-1">{{ $post->published_at->format('M d') }}</span>
		<span class="c-gray-1">{{ $post->published_at->diffForHumans() }}</span>
Commit - Creando las categorías
  -Se usa el comando php artisan make:model Category -m para crear el modelo Category con su migración
  -Se edita la migración create_categories_table para agregar el campo name
    -$table->string('name');
  -Se usa el comando php artisan migrate
  -Se crea la función category en el modelo Post que tendrá la relación belongsTo() - uno a muchos
    -return $this->belongsTo(Category::class);
  -Se edita la migración create_posts_table para agregar el campo category_id después del campo published_at
    -$table->unsignedInteger('category_id');
  -Se usa el comando php artisan migrate:refresh para rehacer las tablas de la BD
  -Se vuelven a crear 2 registros manualmente en la BD en la tabla posts y 2 categorías en la tabla categories
    -Mi primer post--Extracto de mi primer post--<p>Contenido de mi primer post</p>--2019-08-05 13:17:57--2--2019-08-05 13:18:02--2019-08-05 13:18:03"
    -Mi segundo post--Extracto de mi segundo post--<p>Contenido de mi segundo post</p>--2019-08-05 13:17:57--1--2019-08-05 13:18:02--2019-08-05 13:18:03"
    -Categoría 1
    -Categoría 2
  -Se edita la vista welcome para mostrar la categoría usando la relación belongsTo
    -$post->category->name
      -Dónde $post es la variable del foreach, category es la función con belongsTo y name es el campo de la tabla categories
Commit - Implementando Seeders
  -Se crea el seeder usando el comando php artisan make:seeder PostsTableSeeder
  -Se registra PostsTableSeeder en el archivo DatabaseSeeder.php
  -Se edita la función run de PostsTableSeeder para crear posts
    Nota: No olvidar importar la clase Post y Category
      -use App\Post;
      -use App\Category;
    -Si se usa Carbon
      Nota: No olvidar importar la clase Carbon
        -use Carbon\Carbon;
  -Se usa el comando php artisan migrate:refresh para probar los seeds
  -Se usa el comando php artisan db:seed para llenar con información desde los seeders
    Nota: También se puede usar php artisan migrate:refresh --seed para refrescar las tablas y agregar los seeds
Commit - Creando las etiquetas
  -Se crea el modelo Tag con su migración usando el comando php artisan make:model Tag -m
    -Se edita la migración create_tags_table agregando el campo name
      -$table->string('name');
  -Se usa el comando php artisan migrate
  -Se crea la migración create_post_tag_table que guardará la relación belongsToMany entre posts y tags
    -php artisan make:migration create_post_tag_table --create=post_tag
      -Se agregan los campos para guardar los id's de la posts Post y la tabla tags
        $table->unsignedInteger('post_id');
        $table->unsignedInteger('tag_id');
  -Se usa el comando php artisan migrate
  -Se crean 2 registros manualmente en la BD para crear etiquetas
    -Etiqueta 1
    -Etiqueta 2
  -Se crean relaciones entre etiquetas y posts colocando los id's correspondientes de forma manual en la tabla post_tag de la BD
    -1 -- 1 .. dónde 1 es el id del post y 1 es el id del tag
    -1 -- 2 .. dónde 1 es el id del post y 2 es el id del tag
    -2 -- 1 .. dónde 2 es el id del post y 1 es el id del tag
    -3 -- 2 .. dónde 3 es el id del post y 2 es el id del tag
    -4 -- 1 .. dónde 4 es el id del post y 1 es el id del tag
    -4 -- 2 .. dónde 4 es el id del post y 2 es el id del tag
    -5 -- 1 .. dónde 5 es el id del post y 1 es el id del tag
  -Se crea la función tags en el modelo Post para hacer la relación muchos a muchos(belongsToMany)
    - return $this->belongsToMany(Tag::class);
  -Se edita la vista welcome.blade.php para mostrar las etiquetas
    -@foreach ($post->tags as $tag)
      -#{{ $tag->name }}
    -@endforeach
Commit - Integrando plantilla de administración AdminLTE
   -Se descarga la plantilla de AdminLTE 2.3.11 desde el sitio
    -https://github.com/ColorlibHQ/AdminLTE/releases/tag/v2.3.11
  -Se crea la carpeta adminlte en public/
    -Se copian dentro, las carpetas dist/css, dist/img, dist/js, bootstrap y plugins del archivo original al proyecto laravel5.4-BlogUdemy
  -Se crea la carpeta admin en resources/views/ y dentro el archivo layout.blade.php
  -Se copia el contenido del archivo starter.html y se pega en la vista layout.blade.php
  -Se edita la vista admin/layout.blade.php para modificar los href de la vista layout.blade.php para que apunten a la carpeta /adminlte/
    -En el apartado Main Content se agrega la directiva @yield('content')
  -Se crea la vista dashboard.blade.php dentro de la carpeta admin en resources/views/
  -Se edita el archivo web.php
    -Se elimina la ruta de prueba
    -Se crea la ruta admin 
Commit - Integrando el login
  -Se usa el comando php artisan make:auth --views para generar los archivos básicos para integrar el login
    -Dónde --views es un parámetro para solo crear las vistas de autenticación
  Nota: Se elimina el archivo app.css en public/css/ para igualar lo que se hace en el curso(no sé en que momento se eliminó)
  -Se copian las rutas de la función auth() que están en vendor/laravel/framework/src/Illuminate/Routing/Router.php(línea 1007)
   y se pegan en web.php
  -Se pone entre comentarios las rutas para Register
    Nota: Aparece un error de que la ruta register no está definida
    -Error: Route [register] not defined. (View: C:\laragon\www\Laravel5-4_BlogUdemy\resources\views\layouts\app.blade.php)
    Solución: Se debe editar la vista layouts.app.blade.php
      -Quitar la línea <li><a href="{{ route('register') }}">Register</a></li>
  -Se elimina la carpeta layouts que viene por defecto con el comando auth porque no se va a usar
  -Se edita la vista login en la directiva @extends para que extienda de admin.layout
  -Al final se copia todo el contenido de la plantilla Adminlte en pages/examples/login.html 
    -Se quitan las directivas extends y section y sin borrar nada se pega arriba porque se usará el código que generó el comando auth
    -Se van reemplazando cosas del código de auth al código de la plantilla de adminlte(muy extenso de documentar)
    -Se borra el código hecho por el comando auth cuando se termina de copiar al código de la plantilla admilte
    -Se actualizan las rutas de los href 
  -Se cambia el lenguaje de los mensajes de error
    -En config/app.php en la variable locale cambias de 'en' por 'es'
    -Se crea la carpeta es dentro de resources/lang 
      -Dónde 'es' es de español
    -Se copian los 4 archivos dentro de la siguiente url https://github.com/caouecs/Laravel-lang/tree/master/src/es
    -Se pegan dentro de resources/lang/es
  -Se le cambia el nombre a la aplicación desde el archivo .env en el campo APP_NAME=Zendero
  -Se le cambia el nombre a la aplicación tambien en el archivo config/app.php
    -Esto: 'name' => env('APP_NAME', 'Laravel'), por: 'name' => env('APP_NAME', 'Zendero'),
  -Se agregó un usuario usando la herramienta Tinker de laravel
    -php artisan tinker
    -$user = new App\User
    -$user->name = "Marco"
    -$user->email = "admin@mail.com"
    -$user->password = bcrypt('123456')
    -$user->save()
  -Se edita la ruta por admin cambiando admin por home
  -Se edita la vista /admin/dashboard.blade.php
    -Poniendo <p>Usuario autenticado: {{ auth()->user()->name }}</p> para comprobar si se inicio sesión
  -Se vuelve a editar la ruta admin agregandole un middleware auth
Commit - Personalizando el menú y utilizando controladores
  -Se edita la vista admin/layout.blade.php
    -Cambiando el title por  <title>{{ config('app.name') }}</title>
    -Varios cambios extenso de documentar
  -Se crea una carpeta llamada partials dentro de vies/admin/ y dentro el fragmento de visat nav.blade.php
  -Se crea la carpeta posts dentro de views/admin/ para guardar todo lo relacionado con los posts y dentro la vista index.blade.php
  -Se crea el controlador HomeController porque en mi proyecto no se genero al momento de usar el comando make:auth
    -php artisan make:controller HomeController
      -Se crea el constructor con el middleware auth
      -Se crea la función index para retornar la vista admin.dashboard
  -Se edita la ruta admin para redirigir a HomeController en su método index 
  -Se crea el controlador PagesController con el comando php artisan make:controller PagesController encargado de listar los posts
    -Se pasa lo que había en la ruta por defecto a la función home de PagesController
      Nota: Importar la clase use App\Post;
  -Se crea el controlador PostsController dentro de la carpeta Admin usando el comando php artisan make:controller Admin/PostsController
    -Se crea la función index devolviendo la vista admin.posts.index
  -Se crea un grupo de rutas para los posts si se está logueado 
Commit - Mostrando los posts en admin con Datatables
  -Se edita la ruta admin en web.php
    -Se le da un nombre a la ruta Route::get('posts', 'PostsController@index');
      -Route::get('posts', 'PostsController@index')->name('admin.posts.idex');
  -Se edita el partial admin/nav.blade.php agregando el href a ver todos los posts
    -href="{{ route('admin.posts.index') }}
  -Se edita la vista admin/layout.blade.php
    -Se corta el contenido de section page header y se cambia por la directiva @yield('header') para poder cambiarlo dependiendo la página
      -El header se agrega en el partial admin/posts/index.blade.php
      -Uno para header y otro para content
  -Para usar datatables se deben agregar los estilos y js en la vista layout.blade.php
    -Se editan los href del css y js para que vincule bien a la carpeta adminlte/
  -Se copia y edita el script de datatables que está al final del archivo pages/tables/data.html y se pega en la vista layout.blade.php
  -Se copia el datatables de pages/tables/data.html y se pega en la vista layout.blade.php
    -Se quita el contenido estático del tbody del datatable porque ahí van los posts de la BD
    -Se agrega el foreach que recorrerá los posts
  -Se edita la función index de PostsController para mandar los posts a la vista
    -$posts = Post::all();
      Nota: Importar el modelo 
        -use App\Post;
  -Se edita la vista admin/posts/index.blade.php
    -Se extiende de layout
    -Contiene 2 section(header y content)
    -Se edita el datatable para mostrar los posts y sus botones de edición y eliminación
Commit - Reestructuración de código y activación de links
  -Se edita el LoginController cambiando el redirect de /home a /admin
  -Se edita el middleware RedirectIfAuthenticated.php cambiando el redirect de /home a /admin
  -Se edita el nombre del controlador HomeController por AdminController
    -Se le cambia el nombre al archivo de HomeController.php por AdminController.php
    -Se cambia el nombre de class HomeController por class AdminController dentro del controlador
  -Se mueve el controlador AdminController a dentro de la carpeta Admin/
    -Edita el namespace del controlador AdminController
      -Esto: namespace App\Http\Controllers; por esto: namespace App\Http\Controllers\Admin; porque está dentro de la carpeta Admin
      Nota: Importar use App\Http\Controllers\Controller;
  -Se mueve la ruta admin a dentro del grupo de rutas Rutas para los posts si se está logueado
  -Se edita la ruta admin 
    -Esto: Route::get('home', 'AdminController@index'); por esto: Route::get('/', 'AdminController@index');
    -Se le da un nombre a la ruta Route::get('/', 'AdminController@index')->name('dashboard');
  -Se edita el partial nav.blade.php modificando los href y clase active para la activación de los links del menú navegación iquierdo
Commit - Creación del formulario para crear posts
  -Se crea la función create en PostsController
  -Se edita los href /admin/nav.blade.php para vincular ahacía vistas usando el herlper route('')
    -Se le agrega admin/posts* para mantener la barra de navegación desplegada {{ request()->is('admin/posts*') ?  'active' : '' }}
  -Se crea la ruta create en el grupo de rutas de admin
    -Route::get('posts/create', 'PostsController@create')->name('admin.posts.create');
  -Se crea y se edita la vista admin/posts/create.blade.php
  -Se edita la vista nav.blade.php para activar el link de navegación crear un post
  -Se editan los href de section header en los partials index.blade.php y  create.blade.php
Commit - Implementación de un selector de fechas 'datapicker'
  -Se copia el datepicker seleccionado de adminlte/pages/forms/advanced.html y se pega en la vista create.blade.php
  -Se edita la vista admin/layout.blade.php
    -Se usa la directiva @stack('') para cargar archivos solo en la vista que lo necesitemos
      -@stack('styles') para los css y para utilizar stack se usa la directiva @push en la vista donde se usen los archivos
      -@stack('scripts') para los js y para utilizar stack se usa la directiva @push en la vista donde se usen los archivos
  -Se edita la vista admin/create.blade.php
    -Se usa la directiva @push('') para elegir que archivos irán en la directiva @stack
      -Se crea la directiva @push('styles') y @push('scripts') en la vista admin/create.blade.php
    -Se editan los href y src de los archivos importados para tener bien las referencias
    -Se crea el select para las categorías
    -Se crea el botón guardar
  -Se edita la vista admin/index.blade.php
    -Se usa la directiva @push('') para elegir que archivos irán en la directiva @stack
      -Se crea la directiva @push('styles') y @push('scripts') en la vista admin/index.blade.php
    -Se editan los href y src de los archivos importados para tener bien las referencias
  -Se edita la función create de Admin/PostsController para mostrar todas las categorías en el select de la vista create.blade.php
    Nota: Importar el modelo use App\Category;
Commit - Integrando un editor de contenido y un selector múltiple
  -Se importa Ck Editor 4.6.2 dentro de la directiva push en la vista /admin/posts/create.blade.php
    -Se implementa ck editor en la directiva @push('scripts') y se hace referencia el id con el id del textarea del html
  -Se copia el contenido del select de adminlte/pages/forms/advanced.html y se pega en admin/posts/create.blade.php
    -Se pega debajo de categorías
  -Se importa Select2 dentro de la directiva push en la vista /admin/posts/create.blade.php
    -Se editan los href y src de los archivos importados para tener bien las referencias
  -Se edita la función create de Admin/PostsController para mostrar todos los tags en el select de la vista create.blade.php
    Nota: Importar el modelo use App\Tag;
Commit - Guardando las publicaciones
  -Se edita la vista admin/posts/create.blade.php
    -Se modifica el action y method del form
    -Se agrega el token csrf dentro y hasta arriba de la etiqueta form
    -Se le agrega la propiedad name="category" al elemento select de categorías
    -Se le agrega la propiedad name al elemento select de etiquetas
      Nota: Al ser un array la propiedad name debe ser name="tags[]"
  -Se edita web.php para crear la ruta admin.posts.store detro del grupo de Rutas Admin para los posts si se está logueado
  -Se edita el modelo Post para agregar la propiedad guard para que omita el error de asignación masiva
  -Se crea y edita la función store de PostsController
    Nota: Importar use Carbon\Carbon; si se usa la librería Carbon
      -Despues de guardar el post y formatear el campo published_at con Carbon
      -Se usa la relación tags que está en el modelo Post para guardar las etiquetas usando el método attach() o adjuntar en español
      -Se regresa a la página anterior con una variable de sesión que contiene el mensaje
  -Se edita la vista admin/layout.blade.php para agregar la variable de sesión flash enviada desde el controlador
  Nota: Al momento de ver los posts en https://laravel5-4_blogudemy.it/ mostró un error porque en la BD había un registro con el
        campo published_at vacío
        -Solución Agregarle una fecha al campo published_at o eliminar el registro
Commit - Validando el formulario para crear posts
  -Se edita la función create de PostsController para agregar la validación
    -Se cambia esto: $post->published_at = Carbon::parse($request->get('published_at')); 
    -Por esto: $post->published_at = $request->has('published_at') ?  Carbon::parse($request->get('published_at')) : null;
    Nota: Acá hay un error, al momento de mostrar los posts en la página principal https://laravel5-4_blogudemy.it/
          -Error: Call to a member function format() on null
            Nota:Se debe a que guarda null en el campo published_at
              Nota:Se soluciona más adelante en otro commit.
  -Se edita la vista admin/posts/create.blade.php 
    -Se muestran los errores de validación
    -Se corrigió una palabra que estaba mal escrita en el placeholder de contenido y extracto
    -Se corrigió que no mostraba el texto de placeholder en el extracto por el orden del elemento textarea en el html
      -El placeholder de body no funciona por usar CkEditor, si se quita si funciona
    -Se agrega el método old('') para que en caso de mostrar un error de validación, no se pierda la información
      Nota: El tratamiento de old para categories y tags es diferente
        -Para categories es: <option value="{{ $category->id }}" {{ old('category') == $category->id ? 'selected' : '' }}>
        -Para tags es:  <option {{ collect(old('tags'))->contains($tag->id) ? 'selected' : '' }} value="{{ $tag->id }}">{{ $tag->name }}</option>
          -Dónde collect(old('tags')) es para convertirlo en una colección
          -Dónde contains($tag->id) es para comprobar si contiene $tag->id
          -Dónde ? 'selected' : '' si lo contiene colocale la propiedad selected, de lo contrario no coloques nada
Commit - Query scopes
  -Se edita la función home de PagesController para no mostrar los posts sin fecha de publicación(published_at) o futuros
    Nota: Importar la librería carbon 
      -use Carbon\Carbon;
      Nota: Si la consulta SQL se pasa a un query scope y no se usa la librería carbon en el controlador, se puede quitar la referencia a carbon
        -Quitar: use Carbon\Carbon;
    Nota: Se soluciona el error al momento de mostrar los posts en la página principal https://laravel5-4_blogudemy.it/
      -Error: Call to a member function format() on null
        Nota:Se debe a que guarda null en el campo published_at
    -Se usa el query scope en la función home
      -$posts = Post::published()->get();
        -Dónde published() es la scope scopePublished creado en el modelo Post
  -Se crea un query scope llamado scopePublished() en el modelo Post para sustituir la búsqueda de los posts que se hace en PagesController
    Nota: Importar la librería carbon 
      -use Carbon\Carbon;
Commit - Mostrando los posts individuales
  -Se edita la vista welcome.blade.php
    -Se edita el href junto con el texto para vincular al post individual
  -Se crea el controlador PostsController que es diferente a admin/PostsController
    -Este controlador servirá para cuando no es admin
      -php artisan make:controller PostsController
    -Se crea la función show en PostsController
  -Se crea la carpeta posts en resources/views y dentro la vista show.blade.php
    -Se edita la vista show.blade.php
      -Se copia contenido de la plantilla Zendero del archivo single-post.html
        -Es extenso de documentar
    -Esta vista es para mostrar los posts individuales sin ser admin
    -Se corta el contenido de disqus que está entre la etiqueta script
      -Se crea la carpeta partials en resources/views para guardar archivos de terceros
        -Dentro se crea el archivo disqus-script.blade.php
          -Aquí se pega el contenido del script cortando anteriormente
    -Se usa la directiva @include('disqus-script') para agregar disqus a la vista show.blade.php
    -Se reemplaza el contenido estático por contenido de la BD
      -Demasiados cambios como para documentar
    -Se edita la función show de PostsController para vincular la vista con el contenido de la BD
      -$post = Post::find($id);
      Nota: Importar el modelo
        -use App\Post;
  Nota: Al mostrar el post individual hubo un error en los estilos por lo que no se mostraban
  -Se edita la vista layout.blade.php
    -Solución: A los estilos se les agregó un barra diagonal '/' a los href
    -Se agrega la directiva @stack('scripts') para vincular los css
    -Se edita el href de home del menú principal
Commit - Generando url's amigables
  -Se arregla un error con imágenes que no se mostraban en la vista posts/show.blade.php
    -Se copia la carpeta flat_web_icon_set que está en la plantilla Zendero/img y se pega en public/ del proyecto
  -Se edita la función show de PostsController para implementar Model Binding
  -Se edita web.php
    -Esto: Route::get('blog/{id}', 'PostsController@show'); por esto: Route::get('blog/{post}', 'PostsController@show');
  -Se crea la función getRouteKeyName() en el modelo Post para sobreescribir la función y que pueda mostrar otro campo diferente a id
  Nota: Para que en lugar de ver el id en la url se vea algún otro campo
  -Se crea un nuevo campo en la migración create_posts_table
    -$table->string('url');
  -Se usa el comando php artisan migrate:refresh --seed
  -Acá hubo un error ya que el campo url no tiene un valor por defecto
    -Se edita el seed PostsTableSeeder para darle un valor por defecto al campo url al crear el seed
      -Ejemplo: $post->url = str_slug("Mi primer post");
  -Se edita el href de Leer más de la vista welcome.blade.php 
    -Se cambia $post->id por $post->url
  -Se crea un usuario usando Tinker
    -php artisan tinker
    -$user = new App\User;
    -$user->name = "Marco"
    -$user->email = "admin@mail.com"
    -$user->password = bcrypt('123456')
    -$user->save()
    -exit
  -Se edita la función create de Admin/PostsController
    -Se agrega: $post->url = str_slug($request->get('title'));
  -Se crean 2 etiquetas manualmente desde la BD
Commit - Título y descripción para SEO
  -Se edita la vista layout.blade.php
    -Se usa la directiva @yield('') para que el título sea dinámico en cada página
      -	<title>@yield('meta-title', config('app.name') . ' | Blog')</title>
    -Se crea la etiqueta para la descripción del sitio
      <meta name="description" content="@yield('meta-description', 'Este es el blog de Zendero')">
  -Se edita la vista /posts/show.blade.php para cambiar el atributo meta-title
    -@section('meta-title', $post->title)
    -@section('meta-description', $post->excerpt)
Commit - Social links
  -Se edita el archivo public/styles.css
    -Se agrega estilos a los botones de redes sociales
  -Se edita la vista posts/show.blade.php
    -Se comodan los botones de redes sociales
    Nota: Al momento de crear este proyecto Google+ ya no está disponible pero se mantiene el link para fines prácticos
    -Se editan los href de los links de redes sociales
    Nota:Tuve un error por la url del proyecto, pero funciona correctamente con la url sin carácteres especiales
    -Funciona: https://blogudemy1.it/blog/mi-cuarto-post
    -No funciona: https://laravel5-4_blogudemy.it/blog/mi-quinto-post
    -Se corta los links de redes sociales y se pega en el partial partials/social-links.blade.php
  -Se crea el partial social-links.blade.php dentro de la carpeta resources/views/partials/
    -Se edita para que el partial sea reutilizable y no dependa de variables pasadas a través del controlador 
      -@include('partials.social-links', ['description' => $post->title])
    -Se pega el contenido cortado de la vista posts/show.blade.php
Commit - Actualizar posts
  -Se edita la vista admin/posts/index.blade.php 
    -Se agrega un botón para crear un post
      -Se agrega el modal vinculado a este botón
    -Se copian ciertas cosas de la vista admin/posts/create.blade.php
  -Se edita Admin/PostsController 
    -Se comenta la función store(sé usará más adelante en este mismo commit)
    -Se crea una nueva función store para el modal que solo requiere el title
    -Se crea la función edit 
  -Se crea la ruta admin.posts.edit en web.php dentro de las rutas admin
    -Route::get('posts/{post}', 'PostsController@edit')->name('admin.posts.edit');
  -Se crea la vista edit.blade.php dentro de resources/views/admin/
  -Se edita la migración create_posts_table para aceptar valores nulos
    -$table->mediumText('excerpt')->nullable();
    -$table->text('body')->nullable();
    -$table->unsignedInteger('category_id')->nullable();
  -Se crea un seeder para los usuarios
    -php artisan make:seed UsersTableSeeder
    -Se edita UsersTableSeeder
      Nota: Importar el modelo User
        -use App\User;
  -Se registra UsersTableSeeder en DatabaseSeeder.php
  -Se usa el comando php artisan migrate:refresh --seed
  -Se corta todo el contenido de admin/posts/create.blade.php y se pega en admin/posts/edit.blade.php
  -Se edita Admin/PostsController
    -Se pone entre comentarios la función create
    -Se copia el contenido de la función create y se pega en la función edit
    -Se edita la función edit
  -Se edita la vista admin/posts/edit.blade.php
    -Se usa casi lo mismo que en admin/posts/create
    -Se agregó un valor por defecto al método old()
      -Se hizo una condición ternearia en la función old de published_at para arreglar el error por intentar darle formato a null(osea sin fecha)
        -old('published_at', $post->published_at ? $post->published_at->format('m/d/Y') : null) }}"
    -Se edita el action del form
    -Se agrega después de csrf_field 
      -{{ method_field('PUT') }}
  -Se crea la ruta admin.posts.update en web.php dentro de las rutas admin
    -Route::put('posts/{post}', 'PostsController@update')->name('admin.posts.update');
  -Se edita Admin/PostsController cambiandole el nombre a la función comentada store por update
    -Se edita la función update
      -Se quita la instancia de nuevo Post ya que es pasada por parámetro por el modal
      -Se agrega la validación al campo tags
      -Se cambia el mensaje de la variable de sesión flash
  -Se edita PostsTableSeeder para asignar etiquetas usando seeds
    Nota: Importar el modelo Tag
      -use App\Tag;
    -Se usa en cada post para djuntar una etiqueta a cada post
      - $post->tags()->sync(Tag::create(['name' => 'Etiqueta 1']));
  -Se usa el comando php artisan migrate:refresh --seed
  -Se edita la migración create_post_tag_table quitando el campo timestamps ya que no se usa
  -Se usa el comando php artisan migrate:refresh --seed
  -Se edita la vista admin/posts/index.blade.php 
    -Se corta el modal y se pega en admin/posts/create.blade.php
  -Se edita la vista admin/partials/nav.blade.php
Commit - Subir imágenes con DrozoneJs
  -Se edita la vist a admin/posts/create.blade.php
    -Se le agrega la propiedad required al elemento title 
  -Error al momento de guardar un post porque redirige a una ruta que ya no existe porque fue cambiado el nombre del post
  Solución
  -Se edita la función update en el redirect de Admin/PostsController
    -return redirect()->route('admin.posts.edit', $post)->with('flash', 'Tu publicación ha sido guardada');
  -Se obtiene DropzoneJs del cdn del sitio web
    -https://cdnjs.com/libraries/dropzone/5.0.1 la versión minificada
    -JS
      -https://cdnjs.cloudflare.com/ajax/libs/dropzone/5.0.1/min/dropzone.min.js
    -CSS
      -https://cdnjs.cloudflare.com/ajax/libs/dropzone/5.0.1/dropzone.css
  -Se edita admin/posts/edit.blade.php 
    -Se importa DropzoneJs tanto en la directiva push de css como de js
    -Se crea el área donde se mostrarán las imágenes
    -Se crea el código javascript de dropzone para editar el mensaje, la url.
  -Se crea el modelo Photo junto con una migración y el controlador
    -php artisan make:model Photo -mc
  -Se crea la ruta para guardar las imágenes dentro del grupo de rutas admin
  Nota: Se debe mover el controlador PhotoController dentro de la carpeta de Admin
    -Se le debe cambiar el nombre al controlador por PhotosController.php
    -Se le cambia el nombre en el namespace dentro del controlador PhotosController
  -Se crea la función store dentro de PhotosController
    Nota: Importar el modelo Post
      -use App\Post;
      -use App\Http\Controllers\Controller;
      -Se le debe cambiar el namespace porque el controlador está dentro de la carpeta Admin
        -Esto: namespace App\Http\Controllers;
        -Por esto: namespace App\Http\Controllers\Admin;
Commit - Validando las imágenes con DropzoneJs
  -Se edita la vista admin/posts/edit.blade.php
    -Se le agrega la propiedad acceptedFile para indicarle que tipo de archivo es el que se va a subir
      -acceptedFiles: 'image/*',
        -Dónde el * es para permitir cuqluier extensión de imágenes
    -Se agreg la propiedad maxFilesize para indicarle el tamaño máximo permitido
      -maxFilesize: 2,
        -La cantidad está en megabytes
        -Dónde 2 debe ser el tamaño máximo del archivo imagen
    -Dropzone regresa un array con el nombre file para cambiarle el nombre se usa
      -paramName: 'photo'
    Nota: En la versión 5.4 de laravel para ver el mensaje de error es así res.photo[0];
          pero en laravel 5.7 donde se había hecho el proyecto antes tenía que ser así res.errors.photo[0];
  -Se edita la función store de Admin/PhotoController
    -Se agregan las validaciones de lado del servidor (Siempre es bueno tener otra capa de seguridad)
    -Se guarda el array photo de dropzone cambiado con paramName 
      -$photo = request()->file('photo');
Commit - Almacenando las imágenes en BD 
  -Se edita la vista admin/posts/index.blade.php 
    -Se agregan los href de los links de operaciones para mostrar(show) y editar(edit) los posts individualmente
      Nota: Faltaba un link para mostrar(show) el post y se agregó
  -Se edita web.php
    -Se le da un nombre a la ruta posts.show
  -Se edita la función store de Admin/PhotosController
    -Si se usa el helper Storage
      -use Illuminate\Support\Facades\Storage;
    Nota: Importar el modelo Photo
      -use App\Photo;
  -Se usa el comando php artisan storage:link para crear un acceso directo de la carpeta storage en la carpeta public
  -Se edita el archivo Instrucciones/Instalación.txt
  -Se edita la migración create_photos_table
    -Se agregan los campos
      $table->unsignedInteger('post_id');
      $table->string('url');
  -Se usa el comando php artisan migrate:refresh --seed
  -Se edita el modelo Photo
    -protected $guarded = false;
  -Se crea la función photos en el modelo Post que tendrá la relación hasMany() - tiene muchos
    -return $this->hasMany(Photo::class);
Commit - Mostrando las imágenes
  -Se usa el comando php artisan migrate:refresh --seed
  -Se edita la vista welcome.blade.php para mostrar las imágenes
  -Se edita la vista posts/show.blade.php para mostrar las imágenes
    -Se edita el archivo public/css/framework.css
      -Se edita la clase container quitando los padding right y left para mejorar el diseño
      Nota: Está entre comentarios /* Editado para Laravel 5.4 BlogUdemy */
    -Se edita el archivo public/css/styles.css 
      -Se edita la clase .masonry .gallery-image {}
      -Se agrega .gallery-image img {}
      -Se agrega .gallery-photos {}
      -Se agrega .overlay {} - Está clase sirve para mostrar el conteo de imágenes que hay a partir de 4 imágenes
      Nota: Está entre comentarios /* Editado para Laravel 5.4 BlogUdemy */ o /* Creado para Laravel 5.4 BlogUdemy */
    -@foreach ($post->photos->take(4) as $photo) para que solo tome 4 fotos
    -@if ($loop->iteration === 4) Hace algo cuando el foreach llega a 4
Commit - Galería de fotos
  -Se edita la vista posts/show.blade.php 
    -Se usa la directiva @elseif($post->photos->count() > 1) para hacer algo si hay más de una imagen
      -Se usa la directiva @include('posts.carousel')
    -Se crea la vista carousel.blade.php dentro de resources/views/posts/
      -Se edita la vista /posts/carousel.blade.php
        -Se agrega el carousel dentro de la vista para después ser incluido en la directiva @elseif() de posts/show.blade.php
        Nota: Se usa Bootstrap 3.3.7 usando la herramienta customize, donde se selecciona lo que se quiere para compilar y descargar    
          -Desde el sitio web: https://getbootstrap.com/docs/3.4/customize/
            -Less files: 
              -Component animations (for JS) (includes collapse)
              -Carousel
            -jQuery plugins
              -Carousel functionality
              -Transitions (required for any kind of animation)
        Nota: No se puede customizar la versión 3.3.7 ya que reedirige a la versión 3.4
        Nota:Se descarga una carpeta comprimida con el nombre de bootstrap.zip se descomprime 
          Nota: Se copia el archivo js/bootstrap.js y se pega en public/js cambiandole el nombre por twitter-bootstrap.js
          Nota: Se copia el archivo css/bootstrap.css y se pega en public/css cambiandole el nombre por twitter-bootstrap.css
        -Se importa twitter-bootstrap en la directiva push de la vista post/show.blade.php
  -Se edita la vista layout.blade.php
    Nota: En el curso no tenía la directiva stack, mientras que en mi proyecto si la tenía
    -Se usa la directiva stack para los estilos 
      @stack('styles')
    -Se mueve la directiva stack de scripts al final del body ya que en el proyecto estaba en el head
      @stack('scripts')
  -Se edita el archivo public/css/styles.css para modificar el carousel de imágenes
Commit - Eliminando imágenes
  -Se edita admin/posts/edit.blade.php para mostrar las imágenes y poder borrarlas
    -Se agrega una configuración a CKEDITOR para aumentar su alto
  -Se crea la ruta admin.photos.destroy dentro de las rutas de admin
    -Route::delete('photos/{photo}', 'PhotosController@destroy')->name('admin.photos.destroy');
  -Se crea y se edita la función destroy en Admin/PhotosController
Commit - Posts con vídeo y audio
  -Se edita la vista welcome.blade.php
    -Se agrega un elseif para comprobar que si no tiene imágenes, muestre el vídeo del post
      -@elseif($post->iframe)
        -Dónde iframe se va a crear en la migración create_posts_table
    Nota: El iframe se guardará en la BD con todo y etiquetas iframe
    -Para mostrar el iframe guardado en la base de datos
      -{!! $post->iframe !!} 
        -Dónde al usar {!!  !!} permite insertar html en la vista
  -Se edita la migración create_posts_table
    -Después del campo excerpt se agrega el campo iframe
      -$table->text('iframe')->nullable();
  -Se usa el comando php artisan migrate:refresh --seed
  -Se agregaron unos comentarios en el archivo public/css/responsive.css
    -La clase .video iframe también será usada para los posts con audio
  -Se edita la vista admin/posts/edit.blade.php
    -Se crea el área para colocar el iframe(después del campo body)
  -Se edita Admin/PostsController
    -Se edita la función update para agregar el campo iframe
  Nota: Al agregar un iframe sea vídeo o audio, considerar el tamaño width: 100%; y height:480px;
  -Se edita la vista posts/show.blade.php
    -Se agrega el área para mostrar el iframe del post si es que tiene
Commit - Paginación personalizada
  -Se edita la función home de PagesController
  -Se edita la vista welcome.blade.php
    -Se quitan los posts que estaba entre comentarios
  -Se usa el comando php artisan vendor:publish --tag=laravel-pagination
    -Este comando publica las vistas de la paginación usada por laravel y así poder editar al gusto
  -Se edita la vista default.blade.php que está en resources/views/pagination/
    -Esta vista se crea al usar el comando php artisan vendor:publish --tag=laravel-pagination
    -Se adapta la paginación de default.blade.php por lo que tiene la plantilla Zendero en la vista welcome.blade.php
      Nota: Tan pronto se adapta, se borra lo que tenía la plantilla Zendero en su paginación
      -Se usan comentarios para indicar que cambios se hicieron
        -{{-- Se agrego este div con la clase pagination Laravel5.4 BlogUdemy --}}
        -{{-- Se agregaron estas clases (todas) Laravel5.4 BlogUdemy --}}
        -{{-- Se agrego la clase pagination-active y se cambio la etiqueta span por a --}}
          Nota: Este comentario es de la línea de abajo pero por esapcio se puso arriba
Commit - Filtrar posts por categoría
  -Se crea el controlador usando el comando php artisan make:controller CategoriesController
    -Se crea la función show dentro de CategoriesController
  -Se elimina la vista home.blade.php
  -Se crea la ruta categories.show en web.php
    -Route::get('categories/{category}', 'CategoriesController@show')->name('categories.show');
  -Se crea la función getRouteKeyName() en el modelo Category
  -Se edita la vista welcome.blade.php
    -Se agrega la etiqueta a en las categorías
    -Se edita el archivo public/css/styles.css
      -Se edita la clase .post .category a{}
       Nota: Está entre comentarios /* Creado para Laravel 5.4 BlogUdemy */
  -Se crea la función posts en el modelo Category para relacionar las categorías con los posts (Tiene muchos - hasMany)
    -return $this->hasMany(Post::class);
Commit - Filtrar posts por etiqueta
  -Se edita la vista welcome.blade.php
    -Se agrega la etiqueta a en las etiquetas
    -Se edita el archivo style.css
      -Se edita la clase .post .tag a{}
       Nota: Está entre comentarios /* Creado para Laravel 5.4 BlogUdemy */
  -Se crea la ruta tags.show en web.php
    -Route::get('tags/{tag}', 'TagsController@show')->name('tags.show');
  -Se crea el controlador TagsController usando el comando php artisan make:controller TagsController
    -Se crea y se edita la función show en TagsController
      Nota: Importar el modelo Tag
        -use App\Tag;
  -Se crea la función getRouteKeyName() en el modelo Tag
  -Se crea la función posts en el modelo Tag para relacionar las etiquetas con los posts (Pertenece a muchos - hasMany)
    -return $this->hasMany(Post::class);
  -Se edita la función show de CategoriesController
Commit - Accesores y mutadores de Eloquent
  -Se edita el modelo Category
    -Se crea el mutator llamado setNameAttribute()
    Nota: Checar la documentación
      -https://laravel.com/docs/5.4/eloquent-mutators#accessors-and-mutators
  -Se edita la migración create_categories_table
    -Se agrega el campo después del campo name
      -$table->string('url')->nullable;
  -Se usa el comando php artisan migrate:refresh --seed
    Nota: Se le agrega temporalmente el método nullable al campo url, se usa el comando migrate:refresh y se le quita el método al campo url
  Nota: El mutador se ejecuta automáticamente
  -Se edita la migración create_tags_table
    -Se agrega el campo después del campo name
      -$table->string('url')->nullable;
  -Se usa el comando php artisan migrate:refresh --seed
  Nota: El mutador se ejecuta automáticamente
   -Se edita el modelo Tag
    -Se crea el mutator llamado setNameAttribute()
    Nota: Checar la documentación
      -https://laravel.com/docs/5.4/eloquent-mutators#accessors-and-mutators
  -Se usa el comando php artisan migrate:refresh --seed
  Nota: El mutador se ejecuta automáticamente
  -Se edita el modelo Post para usar mutadores
    -Se crea el mutator setTitleAttribute
  -Se edita la función update y store de Admin/PostsController
Commit - Creando categorías y etiquetas sobre la marcha
  -Se edita la vista admin/posts/edit.blade.php
    -Se le agrega la clase select2 a las catgeorías y se modifica el script de select2
  -Se edita la función update de Admin/PostsController
  -Se edita el modelo Category 
    -Se agrega la propiedad protected guarded para deshabilitar la asignación masiva 
  -Se edita el modelo Tag 
    -Se agrega la propiedad protected guarded para deshabilitar la asignación masiva 
Commit - Reestructuración de Admin/PostsController
  -Se usa el comando php artisan make:request StorePostRequest
  Nota: Al usar el comando para crear un request, si no existe ningún request, laravel crea la carpeta app/Http/Requests y dentro el request creado
  Nota: Request es creado para almacenar las validaciones
  -Se edita el request StorePostRequest
    -Se cambia esto return false; por esto return true;
    -Se edita la función rules donde irán las validaciones
    -Se pasa el formRequest StorePostRequest por parámetro en la función update de Admin/PostsController
    Nota: Importar el request
      -use App\Http\Requests\StorePostRequest;
    -Se edita el modelo Post para crear mutadores
      -Se crea el mutator setPublishedAtAttribute 
      -Se crea el mutator setCategoryIdAttribute 
      -Se crea la función syncTags que tendrá la lógica que antes estaba en la función update de Admin/PostsController para 
       guardar etiquetas
      -Se quita la propiedad guarded para deshabilitar la protección de asignación masiva
      -Se agrega la propiedad fillable para protección de asignación masiva
  -Se edita la vista admin/posts/edit.blade.php 
    -Se edita el área de categorias cambiando todo de 'category' a 'category_id'
  -Se edita StorePostRequest
    -Cambiando la validación de category por category_id
Commit - Reestructuración de Admin/PhotosController
  -Se edita la función store de Admin/PhotosController
    Nota:No salió igual que en el curso
      -Curso: 'url' => request()->file('photo')->store('posts', 'public'),
      -Proyecto: 'url' => Storage::url(request()->file('photo')->store('posts', 'public')),
      Nota: En el curso el podía acceder https://blog.dev/posts/imagen.jpg y yo no pude acceder así, 
        yo accedo con https://blog.dev/storage/posts/imagen.jpg
      -Se tuvo que dejar pero funciona igual.
  -Se edito la vista posts/show.blade.php para agregar el helper url
    -<figure><img src="{{ url($post->photos->first()->url) }}" alt="" class="img-responsive"></figure>
  -Se edita el modelo Photo
    -Se crea una función estática para que elimine de la carpeta Storage la o las imágenes
      Nota:Reemplaza lo que está entre comentarios en el controlador Admin/PhotosController
      Nota: Importar el Facade
        -use Illuminate\Support\Facades\Storage;
  -Se edita PostsTableSeeder para eliminar las imágenes de Storage al usar el comando php artisan migrate:refresh --seed
    -Storage::disk('public')->deleteDirectory('posts');
    Nota: Dónde public es la configuración de config/filesystems.php y deleteDirectory es la carpeta que se va a eliminar
      Nota:Importar el Facade
        -use Illuminate\Support\Facades\Storage;
  -Se usa el comando php artisan migrate:refresh --seed 
    Nota: Se comprueba si la carpeta posts dentro de Storage/app/ se borra(Si se borra)
Commit - Eliminar posts y sus relaciones
  -Se edita la vista admin/posts/index.blade.php
    -Se agrega la etiqueta al form al botón de eliminar
  -Se crea la ruta admin.posts.destroy dentro de las rutas de admin
    -Route::delete('posts/{post}', 'PostsController@destroy')->name('admin.posts.destroy');
  -Se crea la función destroy en Admin/PostsController
  -Se crea la función boot con la función estática deleting en el modelo Post 
  -Se usa el comando php artisan migrate:refresh --seed para probar si se eliminan las etiquetas correctamente
Commit - Actualizando a Laravel 5.5
  -Se usa el comando composer global update
  -Se usa el comando composer self-update
  -Editar el archivo composer.json
    -Actualizar el framework a 5.5.*
      -"laravel/framework": "5.5.*",
    -Actualizar phpunit/phpunit a ~6.0
      -"phpunit/phpunit": "~6.0",
    -Agregar filp/whoops en su versión ~2.0
      -"filp/whoops": "~2.0"
  -Usar el comando composer update
Commit - Mantener el modal si hay errores
  -Se edita la vista admin/layout.blade.php
    -Se usa la directiva unless para verificar que el modal solo se abra dependiendo la url admin/posts/*
      -Donde * es todo lo que venga después de /
    -Dentro de la directiva unless se incluye la vista del modal @include('admin.posts.create') 
  -Se edita la vista admin/posts/create.blade.php
    -Se le quita la propiedad required al campo title
      Nota: Al final se pone de nuevo
    -Se modifica la ruta del formulario para pasar #create en la url
    -Se le da un id al campo title
    -Se le agrega la propiedad autofocus al campo title
    -Se usa la directiva push con el script para verificar si el modal está abierto
  -Se edita la función store de Admin/PostsController
    -Se agrega una regla de validación al campo title
      -$this->validate($request, ['title' => 'required|min:3']);
  -Se edita la vista admin/partials/nav.blade.php
    -Se le agrega la directiva condicional if para redireccionar dependiendo en que url tenga
Commit - Generando URL's únicas
  -Se edita el modelo Post 
    -Se comenta el mutador setTitleAttribute ya que no se va usar
    -Se crean 2 funciones 
      -Funcíon create que sobreescribe al método create que está en el controlador
      -Función generateUrl encargada de generar la url dinámica hacía la función create
  -Se edita Admin/PostsController
  -Se edita la migración create_posts_table
    -Se edita el campo url
      -Esto $table->string('url'); por esto: $table->string('url')->unique()->nullable;
  -Se usa el comando php artisan migrate:refresh --seed
Commit - Activando la navegación
  -Se Crean las rutas para el menú de navegación en web.php
    -Route::get('/', 'PagesController@home')->name('pages.home');
    -Route::get('nosotros', 'PagesController@about')->name('pages.about');
    -Route::get('archivo', 'PagesController@archive')->name('pages.archive');
    -Route::get('contacto', 'PagesController@contact')->name('pages.contact');
  -Se edita la vista layout.blade.php
    -Se extrae toda la etiqueta nav y se hace un @include('partials.nav') que será la vista de la navegación
  -Se edita la vista partials/nav.blade.php
    -Se usa el helper route para enlazar los href con las rutas 
    -Se crea un helper
  -Se edita el controlador PagesController
    -Se crea la función about
    -Se crea la función archive
    -Se crea la función contact
  -Se crea la carpeta pages en resources/views y dentro las vistas about.blade.php, archive.blade.php y contact.blade.php
  -Se mueve la vista welcome.blade.php a la carpeta resources/vews/pages y se renombra a home.blade.php
  -Se crea el archivo helpers.php en app/Http/
    -Para poderlo usar se debe agregar en composer.json
      -"files": ["app/Http/helpers.php"]
    -Se usa el comando composer dumpautoload -o
Commit - Agregando las páginas estáticas del menú
  -Se copia contenido de la plantilla Zendero del archivo about.html y se pega en la vista pages/about.blade.php
  -Se copia contenido de la plantilla Zendero del archivo archive.html y se pega en la vista pages/archive.blade.php
  -Se copia contenido de la plantilla Zendero del archivo contact.html y se pega en la vista pages/contact.blade.php
  -Se edita CategoriesController para cambiar welcome por pages.home ya que se le cambió el nombre
  -Se edita TagsController para cambiar welcome por pages.home ya que se le cambió el nombre
  -Se edita el archivo public/css/twitter-bootstrap.css 
    -se quita todo antes de la clase carousel
Commit - Acceso a posts no públicos
  -Se edita la vista posts/show.blade.php
    -Se le agrega el helper optional para poder ver el post desde admin, ya que sin fecha mostraba error 
     de que no se le puede dar formato si el valor es null 
      -<span class="c-gris">{{ optional($post->published_at)->format('M d') }}</span>
			-<span class="c-gris">- {{ optional($post->published_at)->diffForHumans() }}</span>
    -Se agrega la directiva @if para comprobar si $post->category tiene un valor porque mostraba un error 
     si el post no tenía categoría
  -Se edita la función show de PostsController
  -Se crea la función isPublished() en el modelo Post
  -Se crea la carpeta errors en resources/views y dentro se crea la vista 404.blade.php
    -Se edita la vista 404.blade.php
Commit - Asignar posts a usuarios
  -Se edita la migración create_posts_table
    -Se agrega el campo user_id después de category_id
      $table->unsignedInteger('user_id');
  -Se edita la función store de Admin/PostsController
  -Se edita PostsTableSeeder
    -Se agrega a los posts
      -$post->user_id = 1;
  -Se usa el comando php artisan migrate:refresh --seed
  -Se edita el modelo Post
    -Se agrega el campo user_id a la propiedad fillable
  -Se edita el modelo User
    -Se crea la función posts para indicar la relación hasMany
  -Se edita el modelo Post
    -Se crea la función owner para indicar la relación belongsTo
      -return $this->belongsTo(User::class, 'user_id');
        -Dónde 'user_id' es el campo que va referenciado porque de lo contrario buscaría el campo 'owner_id' por convención
  -Se edita la vista pages/home.blade.php para mostrar al creador del post
Commit - Reestructuración de vistas
  -Se edita la vista posts/show.blade.php
    -Se corta el contenido de la etiqueta header
    -Se usa la directiva @include para vincular con la vista posts/header.blade.php
    -Se usa la directiva @include para vincular con la vista posts/tags.blade.php
    -Se usa la directiva @include para vincular con la vista posts/photo.blade.php
    -Se usa la directiva @include para vincular con la vista posts/iframe.blade.php
  -Se edita la vista home.blade.php
    -Se quita el contenido de la etiqueta header
    -Se usa el helper route en el href de leer más
    -Se corta el área de las etiquetas y se pega en la vista posts/tags.blade.php
    -Se usa la directiva @include para vincular con la vista posts/header.blade.php
    -Se usa la directiva @include para vincular con la vista posts/tags.blade.php
    -Se corta el contenido dentro de elseif($post->photos->count() > 1) para pasarse a la vista carousel-preview.blade.php
    -Se corta el contenido dentro de @if ($post->photos->count() === 1) para pasarse a la vista posts/photo.blade.php
    -Se usa la directiva @include para vincular con la vista posts/photo.blade.php
    -Se corta el contenido dentro de @elseif($post->iframe) para pasarse a la vista posts/iframe.blade.php
    -Se usa la directiva @include para vincular con la vista posts/iframe.blade.php
  -Se crea la vista header.blade.php en resources/views/posts/
    -Se pega el header en la vista posts/header.blade.php, el que fue cortado de la vista posts/show.blade.php
  -Se crea la vista tags.blade.php en resources/views/posts/
    -Se pega el área de las etiquetas que fue cortado de la vista home.blade.php y se pega en posts.tags
  -Se crea la vista carousel-preview.blade.php en resources/views/posts/
    -Se pega el contenido cortado de la vista home.blade.php
  -Se crea la vista photo.blade.php en resources/views/posts/
    -Se pega el contenido cortado de la vista home.blade.php
  -Se crea la vista iframe.blade.php en resources/views/posts/
    -Se pega el contenido cortado de la vista home.blade.php