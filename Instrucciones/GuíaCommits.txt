Commit - Creación del proyecto Laravel5-4_BlogUdemy
  -composer create-project --prefer-dist laravel/laravel Laravel5-4_BlogUdemy "5.4.*"
Commit - Se crea la carpeta Instrucciones
  -Se crea el archivo Instalación.txt
  -Se crea el archivo GuíaCommits.txt
Commit - Integrando la plantilla Zendero al proyecto Laravel5-4_BlogUdemy
  -Se copian las carpetas css, img y js de la carpeta descargada(Zendero) y se pegan en public/ del proyecto Laravel5-4_BlogUdemy
  -Se copia el contenido del archivo index.html de la carpeta descargada(Zendero) y se pega en la vista welcome.blade.php
  -Se edita la vista welcome quitando las partes que se usarán en todas las vistas y se pasa a la vista layout.blade.php
    -Se usan las directivas (@extends y @section) para vincular la vista con layout.blade.php
  -Se crea la vista layout.blade.php
    -Esta vista tendrá todo lo que se repite(head, header y footer) y las demás vistas solo agregarán el contenido del post
    -Se edita la vista layout usando la directiva (yield) para vincular con la directiva section
Commit - Creando la tabla posts y BD
  -Se modifica el archivo .env
    APP_URL=https://laravel5-4_blogudemy.it/
    DB_DATABASE=laravel54blogudemy
    DB_USERNAME=root
    DB_PASSWORD=
    -La base de datos se creó desde consola
      -se usa el comando mysql -uroot
      -CREATE DATABASE laravel54blogudemy;
  -Se usa el comando php artisan migrate
  -Error si se usa MariaDB : Specified key was too long; max key length es 767 bytes
    -Solución: Ir a app/Providers/appServiceProvider.php
      -En la función boot agregar:
        -Schema::defaultStringLength(191);
        Nota: Importar el Facade 
          -use Illuminate\Support\Facades\Schema;
    Nota: Solo si hubo el error se vuelve a usar el comando php artisan migrate
  -Se usa el comando php artisan make:model Post -m para crear un modelo con su migración
    -Dónde Post es el nombre del modelo, m es migración
  -Se edita la migración create_posts_table agregando los campos
    $table->string('title');
    $table->mediumText('excerpt');
    $table->text('body');
    $table->timestamp('published_at')->nullable();
  -Se usa el comando php artisan migrate
Commit - Mostrando los posts desde la BD
  -Se crean 2 campos manualmente en la tabla Posts en la BD
    -Mi primer post -- Extracto de mi primer post -- <p>Contenido de mi primer post</p>
  -Se crea una ruta de prueba en web.php
  -Se edita la ruta por defecto en web.php
  -Se edita la vista welcome.blade.php para mostrar los Posts que fueron agregados manualmente
    Nota: Se dejaron entre comentarios los posts que no se usan todavía
    -Se edita el post con la clase post no-image
      -Se usa la directiva @foreach ($posts as $post) para mostrar todos los posts
Commit - Mostrando la fecha de publicación de los posts
   -Se edita el modelo Post agregando
    -protected $dates = ['published_at']; para decir que el campo published_at también sea una instancia de carbon la librería
  -Se edita la vista welcome para mostrar la fecha
    <span class="c-gray-1">{{ $post->published_at->format('M d') }}</span>
		<span class="c-gray-1">{{ $post->published_at->diffForHumans() }}</span>
Commit - Creando las categorías
  -Se usa el comando php artisan make:model Category -m para crear el modelo Category con su migración
  -Se edita la migración create_categories_table para agregar el campo name
    -$table->string('name');
  -Se usa el comando php artisan migrate
  -Se crea la función category en el modelo Post que tendrá la relación belongsTo() - uno a muchos
    -return $this->belongsTo(Category::class);
  -Se edita la migración create_posts_table para agregar el campo category_id después del campo published_at
    -$table->unsignedInteger('category_id');
  -Se usa el comando php artisan migrate:refresh para rehacer las tablas de la BD
  -Se vuelven a crear 2 registros manualmente en la BD en la tabla posts y 2 categorías en la tabla categories
    -Mi primer post--Extracto de mi primer post--<p>Contenido de mi primer post</p>--2019-08-05 13:17:57--2--2019-08-05 13:18:02--2019-08-05 13:18:03"
    -Mi segundo post--Extracto de mi segundo post--<p>Contenido de mi segundo post</p>--2019-08-05 13:17:57--1--2019-08-05 13:18:02--2019-08-05 13:18:03"
    -Categoría 1
    -Categoría 2
  -Se edita la vista welcome para mostrar la categoría usando la relación belongsTo
    -$post->category->name
      -Dónde $post es la variable del foreach, category es la función con belongsTo y name es el campo de la tabla categories
Commit - Implementando Seeders
  -Se crea el seeder usando el comando php artisan make:seeder PostsTableSeeder
  -Se registra PostsTableSeeder en el archivo DatabaseSeeder.php
  -Se edita la función run de PostsTableSeeder para crear posts
    Nota: No olvidar importar la clase Post y Category
      -use App\Post;
      -use App\Category;
    -Si se usa Carbon
      Nota: No olvidar importar la clase Carbon
        -use Carbon\Carbon;
  -Se usa el comando php artisan migrate:refresh para probar los seeds
  -Se usa el comando php artisan db:seed para llenar con información desde los seeders
    Nota: También se puede usar php artisan migrate:refresh --seed para refrescar las tablas y agregar los seeds
Commit - Creando las etiquetas
  -Se crea el modelo Tag con su migración usando el comando php artisan make:model Tag -m
    -Se edita la migración create_tags_table agregando el campo name
      -$table->string('name');
  -Se usa el comando php artisan migrate
  -Se crea la migración create_post_tag_table que guardará la relación belongsToMany entre posts y tags
    -php artisan make:migration create_post_tag_table --create=post_tag
      -Se agregan los campos para guardar los id's de la posts Post y la tabla tags
        $table->unsignedInteger('post_id');
        $table->unsignedInteger('tag_id');
  -Se usa el comando php artisan migrate
  -Se crean 2 registros manualmente en la BD para crear etiquetas
    -Etiqueta 1
    -Etiqueta 2
  -Se crean relaciones entre etiquetas y posts colocando los id's correspondientes de forma manual en la tabla post_tag de la BD
    -1 -- 1 .. dónde 1 es el id del post y 1 es el id del tag
    -1 -- 2 .. dónde 1 es el id del post y 2 es el id del tag
    -2 -- 1 .. dónde 2 es el id del post y 1 es el id del tag
    -3 -- 2 .. dónde 3 es el id del post y 2 es el id del tag
    -4 -- 1 .. dónde 4 es el id del post y 1 es el id del tag
    -4 -- 2 .. dónde 4 es el id del post y 2 es el id del tag
    -5 -- 1 .. dónde 5 es el id del post y 1 es el id del tag
  -Se crea la función tags en el modelo Post para hacer la relación muchos a muchos(belongsToMany)
    - return $this->belongsToMany(Tag::class);
  -Se edita la vista welcome.blade.php para mostrar las etiquetas
    -@foreach ($post->tags as $tag)
      -#{{ $tag->name }}
    -@endforeach
Commit - Integrando plantilla de administración AdminLTE
   -Se descarga la plantilla de AdminLTE 2.3.11 desde el sitio
    -https://github.com/ColorlibHQ/AdminLTE/releases/tag/v2.3.11
  -Se crea la carpeta adminlte en public/
    -Se copian dentro, las carpetas dist/css, dist/img, dist/js, bootstrap y plugins del archivo original al proyecto laravel5.4-BlogUdemy
  -Se crea la carpeta admin en resources/views/ y dentro el archivo layout.blade.php
  -Se copia el contenido del archivo starter.html y se pega en la vista layout.blade.php
  -Se edita la vista admin/layout.blade.php para modificar los href de la vista layout.blade.php para que apunten a la carpeta /adminlte/
    -En el apartado Main Content se agrega la directiva @yield('content')
  -Se crea la vista dashboard.blade.php dentro de la carpeta admin en resources/views/
  -Se edita el archivo web.php
    -Se elimina la ruta de prueba
    -Se crea la ruta admin 
Commit - Integrando el login
  -Se usa el comando php artisan make:auth --views para generar los archivos básicos para integrar el login
    -Dónde --views es un parámetro para solo crear las vistas de autenticación
  Nota: Se elimina el archivo app.css en public/css/ para igualar lo que se hace en el curso(no sé en que momento se eliminó)
  -Se copian las rutas de la función auth() que están en vendor/laravel/framework/src/Illuminate/Routing/Router.php(línea 1007)
   y se pegan en web.php
  -Se pone entre comentarios las rutas para Register
    Nota: Aparece un error de que la ruta register no está definida
    -Error: Route [register] not defined. (View: C:\laragon\www\Laravel5-4_BlogUdemy\resources\views\layouts\app.blade.php)
    Solución: Se debe editar la vista layouts.app.blade.php
      -Quitar la línea <li><a href="{{ route('register') }}">Register</a></li>
  -Se elimina la carpeta layouts que viene por defecto con el comando auth porque no se va a usar
  -Se edita la vista login en la directiva @extends para que extienda de admin.layout
  -Al final se copia todo el contenido de la plantilla Adminlte en pages/examples/login.html 
    -Se quitan las directivas extends y section y sin borrar nada se pega arriba porque se usará el código que generó el comando auth
    -Se van reemplazando cosas del código de auth al código de la plantilla de adminlte(muy extenso de documentar)
    -Se borra el código hecho por el comando auth cuando se termina de copiar al código de la plantilla admilte
    -Se actualizan las rutas de los href 
  -Se cambia el lenguaje de los mensajes de error
    -En config/app.php en la variable locale cambias de 'en' por 'es'
    -Se crea la carpeta es dentro de resources/lang 
      -Dónde 'es' es de español
    -Se copian los 4 archivos dentro de la siguiente url https://github.com/caouecs/Laravel-lang/tree/master/src/es
    -Se pegan dentro de resources/lang/es
  -Se le cambia el nombre a la aplicación desde el archivo .env en el campo APP_NAME=Zendero
  -Se le cambia el nombre a la aplicación tambien en el archivo config/app.php
    -Esto: 'name' => env('APP_NAME', 'Laravel'), por: 'name' => env('APP_NAME', 'Zendero'),
  -Se agregó un usuario usando la herramienta Tinker de laravel
    -php artisan tinker
    -$user = new App\User
    -$user->name = "Marco"
    -$user->email = "admin@mail.com"
    -$user->password = bcrypt('123456')
    -$user->save()
  -Se edita la ruta por admin cambiando admin por home
  -Se edita la vista /admin/dashboard.blade.php
    -Poniendo <p>Usuario autenticado: {{ auth()->user()->name }}</p> para comprobar si se inicio sesión
  -Se vuelve a editar la ruta admin agregandole un middleware auth
Commit - Personalizando el menú y utilizando controladores
  -Se edita la vista admin/layout.blade.php
    -Cambiando el title por  <title>{{ config('app.name') }}</title>
    -Varios cambios extenso de documentar
  -Se crea una carpeta llamada partials dentro de vies/admin/ y dentro el fragmento de visat nav.blade.php
  -Se crea la carpeta posts dentro de views/admin/ para guardar todo lo relacionado con los posts y dentro la vista index.blade.php
  -Se crea el controlador HomeController porque en mi proyecto no se genero al momento de usar el comando make:auth
    -php artisan make:controller HomeController
      -Se crea el constructor con el middleware auth
      -Se crea la función index para retornar la vista admin.dashboard
  -Se edita la ruta admin para redirigir a HomeController en su método index 
  -Se crea el controlador PagesController con el comando php artisan make:controller PagesController encargado de listar los posts
    -Se pasa lo que había en la ruta por defecto a la función home de PagesController
      Nota: Importar la clase use App\Post;
  -Se crea el controlador PostsController dentro de la carpeta Admin usando el comando php artisan make:controller Admin/PostsController
    -Se crea la función index devolviendo la vista admin.posts.index
  -Se crea un grupo de rutas para los posts si se está logueado 
Commit - Mostrando los posts en admin con Datatables
  -Se edita la ruta admin en web.php
    -Se le da un nombre a la ruta Route::get('posts', 'PostsController@index');
      -Route::get('posts', 'PostsController@index')->name('admin.posts.idex');
  -Se edita el partial admin/nav.blade.php agregando el href a ver todos los posts
    -href="{{ route('admin.posts.index') }}
  -Se edita la vista admin/layout.blade.php
    -Se corta el contenido de section page header y se cambia por la directiva @yield('header') para poder cambiarlo dependiendo la página
      -El header se agrega en el partial admin/posts/index.blade.php
      -Uno para header y otro para content
  -Para usar datatables se deben agregar los estilos y js en la vista layout.blade.php
    -Se editan los href del css y js para que vincule bien a la carpeta adminlte/
  -Se copia y edita el script de datatables que está al final del archivo pages/tables/data.html y se pega en la vista layout.blade.php
  -Se copia el datatables de pages/tables/data.html y se pega en la vista layout.blade.php
    -Se quita el contenido estático del tbody del datatable porque ahí van los posts de la BD
    -Se agrega el foreach que recorrerá los posts
  -Se edita la función index de PostsController para mandar los posts a la vista
    -$posts = Post::all();
      Nota: Importar el modelo 
        -use App\Post;
  -Se edita la vista admin/posts/index.blade.php
    -Se extiende de layout
    -Contiene 2 section(header y content)
    -Se edita el datatable para mostrar los posts y sus botones de edición y eliminación
Commit - Reestructuración de código y activación de links
  -Se edita el LoginController cambiando el redirect de /home a /admin
  -Se edita el middleware RedirectIfAuthenticated.php cambiando el redirect de /home a /admin
  -Se edita el nombre del controlador HomeController por AdminController
    -Se le cambia el nombre al archivo de HomeController.php por AdminController.php
    -Se cambia el nombre de class HomeController por class AdminController dentro del controlador
  -Se mueve el controlador AdminController a dentro de la carpeta Admin/
    -Edita el namespace del controlador AdminController
      -Esto: namespace App\Http\Controllers; por esto: namespace App\Http\Controllers\Admin; porque está dentro de la carpeta Admin
      Nota: Importar use App\Http\Controllers\Controller;
  -Se mueve la ruta admin a dentro del grupo de rutas Rutas para los posts si se está logueado
  -Se edita la ruta admin 
    -Esto: Route::get('home', 'AdminController@index'); por esto: Route::get('/', 'AdminController@index');
    -Se le da un nombre a la ruta Route::get('/', 'AdminController@index')->name('dashboard');
  -Se edita el partial nav.blade.php modificando los href y clase active para la activación de los links del menú navegación iquierdo
Commit - Creación del formulario para crear posts
  -Se crea la función create en PostsController
  -Se edita los href /admin/nav.blade.php para vincular ahacía vistas usando el herlper route('')
    -Se le agrega admin/posts* para mantener la barra de navegación desplegada {{ request()->is('admin/posts*') ?  'active' : '' }}
  -Se crea la ruta create en el grupo de rutas de admin
    -Route::get('posts/create', 'PostsController@create')->name('admin.posts.create');
  -Se crea y se edita la vista admin/posts/create.blade.php
  -Se edita la vista nav.blade.php para activar el link de navegación crear un post
  -Se editan los href de section header en los partials index.blade.php y  create.blade.php
Commit - Implementación de un selector de fechas 'datapicker'
  -Se copia el datepicker seleccionado de adminlte/pages/forms/advanced.html y se pega en la vista create.blade.php
  -Se edita la vista admin/layout.blade.php
    -Se usa la directiva @stack('') para cargar archivos solo en la vista que lo necesitemos
      -@stack('styles') para los css y para utilizar stack se usa la directiva @push en la vista donde se usen los archivos
      -@stack('scripts') para los js y para utilizar stack se usa la directiva @push en la vista donde se usen los archivos
  -Se edita la vista admin/create.blade.php
    -Se usa la directiva @push('') para elegir que archivos irán en la directiva @stack
      -Se crea la directiva @push('styles') y @push('scripts') en la vista admin/create.blade.php
    -Se editan los href y src de los archivos importados para tener bien las referencias
    -Se crea el select para las categorías
    -Se crea el botón guardar
  -Se edita la vista admin/index.blade.php
    -Se usa la directiva @push('') para elegir que archivos irán en la directiva @stack
      -Se crea la directiva @push('styles') y @push('scripts') en la vista admin/index.blade.php
    -Se editan los href y src de los archivos importados para tener bien las referencias
  -Se edita la función create de Admin/PostsController para mostrar todas las categorías en el select de la vista create.blade.php
    Nota: Importar el modelo use App\Category;
Commit - Integrando un editor de contenido y un selector múltiple
  -Se importa Ck Editor 4.6.2 dentro de la directiva push en la vista /admin/posts/create.blade.php
    -Se implementa ck editor en la directiva @push('scripts') y se hace referencia el id con el id del textarea del html
  -Se copia el contenido del select de adminlte/pages/forms/advanced.html y se pega en admin/posts/create.blade.php
    -Se pega debajo de categorías
  -Se importa Select2 dentro de la directiva push en la vista /admin/posts/create.blade.php
    -Se editan los href y src de los archivos importados para tener bien las referencias
  -Se edita la función create de Admin/PostsController para mostrar todos los tags en el select de la vista create.blade.php
    Nota: Importar el modelo use App\Tag;
Commit - Guardando las publicaciones
  -Se edita la vista admin/posts/create.blade.php
    -Se modifica el action y method del form
    -Se agrega el token csrf dentro y hasta arriba de la etiqueta form
    -Se le agrega la propiedad name="category" al elemento select de categorías
    -Se le agrega la propiedad name al elemento select de etiquetas
      Nota: Al ser un array la propiedad name debe ser name="tags[]"
  -Se edita web.php para crear la ruta admin.posts.store detro del grupo de Rutas Admin para los posts si se está logueado
  -Se edita el modelo Post para agregar la propiedad guard para que omita el error de asignación masiva
  -Se crea y edita la función store de PostsController
    Nota: Importar use Carbon\Carbon; si se usa la librería Carbon
      -Despues de guardar el post y formatear el campo published_at con Carbon
      -Se usa la relación tags que está en el modelo Post para guardar las etiquetas usando el método attach() o adjuntar en español
      -Se regresa a la página anterior con una variable de sesión que contiene el mensaje
  -Se edita la vista admin/layout.blade.php para agregar la variable de sesión flash enviada desde el controlador
  Nota: Al momento de ver los posts en https://laravel5-4_blogudemy.it/ mostró un error porque en la BD había un registro con el
        campo published_at vacío
        -Solución Agregarle una fecha al campo published_at o eliminar el registro
Commit - Validando el formulario para crear posts
  -Se edita la función create de PostsController para agregar la validación
    -Se cambia esto: $post->published_at = Carbon::parse($request->get('published_at')); 
    -Por esto: $post->published_at = $request->has('published_at') ?  Carbon::parse($request->get('published_at')) : null;
    Nota: Acá hay un error, al momento de mostrar los posts en la página principal https://laravel5-4_blogudemy.it/
          -Error: Call to a member function format() on null
            Nota:Se debe a que guarda null en el campo published_at
              Nota:Se soluciona más adelante en otro commit.
  -Se edita la vista admin/posts/create.blade.php 
    -Se muestran los errores de validación
    -Se corrigió una palabra que estaba mal escrita en el placeholder de contenido y extracto
    -Se corrigió que no mostraba el texto de placeholder en el extracto por el orden del elemento textarea en el html
      -El placeholder de body no funciona por usar CkEditor, si se quita si funciona
    -Se agrega el método old('') para que en caso de mostrar un error de validación, no se pierda la información
      Nota: El tratamiento de old para categories y tags es diferente
        -Para categories es: <option value="{{ $category->id }}" {{ old('category') == $category->id ? 'selected' : '' }}>
        -Para tags es:  <option {{ collect(old('tags'))->contains($tag->id) ? 'selected' : '' }} value="{{ $tag->id }}">{{ $tag->name }}</option>
          -Dónde collect(old('tags')) es para convertirlo en una colección
          -Dónde contains($tag->id) es para comprobar si contiene $tag->id
          -Dónde ? 'selected' : '' si lo contiene colocale la propiedad selected, de lo contrario no coloques nada
Commit - Query scopes
  -Se edita la función home de PagesController para no mostrar los posts sin fecha de publicación(published_at) o futuros
    Nota: Importar la librería carbon 
      -use Carbon\Carbon;
      Nota: Si la consulta SQL se pasa a un query scope y no se usa la librería carbon en el controlador, se puede quitar la referencia a carbon
        -Quitar: use Carbon\Carbon;
    Nota: Se soluciona el error al momento de mostrar los posts en la página principal https://laravel5-4_blogudemy.it/
      -Error: Call to a member function format() on null
        Nota:Se debe a que guarda null en el campo published_at
    -Se usa el query scope en la función home
      -$posts = Post::published()->get();
        -Dónde published() es la scope scopePublished creado en el modelo Post
  -Se crea un query scope llamado scopePublished() en el modelo Post para sustituir la búsqueda de los posts que se hace en PagesController
    Nota: Importar la librería carbon 
      -use Carbon\Carbon;
Commit - Mostrando los posts individuales
  -Se edita la vista welcome.blade.php
    -Se edita el href junto con el texto para vincular al post individual
  -Se crea el controlador PostsController que es diferente a admin/PostsController
    -Este controlador servirá para cuando no es admin
      -php artisan make:controller PostsController
    -Se crea la función show en PostsController
  -Se crea la carpeta posts en resources/views y dentro la vista show.blade.php
    -Se edita la vista show.blade.php
      -Se copia contenido de la plantilla Zendero del archivo single-post.html
        -Es extenso de documentar
    -Esta vista es para mostrar los posts individuales sin ser admin
    -Se corta el contenido de disqus que está entre la etiqueta script
      -Se crea la carpeta partials en resources/views para guardar archivos de terceros
        -Dentro se crea el archivo disqus-script.blade.php
          -Aquí se pega el contenido del script cortando anteriormente
    -Se usa la directiva @include('disqus-script') para agregar disqus a la vista show.blade.php
    -Se reemplaza el contenido estático por contenido de la BD
      -Demasiados cambios como para documentar
    -Se edita la función show de PostsController para vincular la vista con el contenido de la BD
      -$post = Post::find($id);
      Nota: Importar el modelo
        -use App\Post;
  Nota: Al mostrar el post individual hubo un error en los estilos por lo que no se mostraban
  -Se edita la vista layout.blade.php
    -Solución: A los estilos se les agregó un barra diagonal '/' a los href
    -Se agrega la directiva @stack('scripts') para vincular los css
    -Se edita el href de home del menú principal
Commit - Generando url's amigables
  -Se arregla un error con imágenes que no se mostraban en la vista posts/show.blade.php
    -Se copia la carpeta flat_web_icon_set que está en la plantilla Zendero/img y se pega en public/ del proyecto
  -Se edita la función show de PostsController para implementar Model Binding
  -Se edita web.php
    -Esto: Route::get('blog/{id}', 'PostsController@show'); por esto: Route::get('blog/{post}', 'PostsController@show');
  -Se crea la función getRouteKeyName() en el modelo Post para sobreescribir la función y que pueda mostrar otro campo diferente a id
  Nota: Para que en lugar de ver el id en la url se vea algún otro campo
  -Se crea un nuevo campo en la migración create_posts_table
    -$table->string('url');
  -Se usa el comando php artisan migrate:refresh --seed
  -Acá hubo un error ya que el campo url no tiene un valor por defecto
    -Se edita el seed PostsTableSeeder para darle un valor por defecto al campo url al crear el seed
      -Ejemplo: $post->url = str_slug("Mi primer post");
  -Se edita el href de Leer más de la vista welcome.blade.php 
    -Se cambia $post->id por $post->url
  -Se crea un usuario usando Tinker
    -php artisan tinker
    -$user = new App\User;
    -$user->name = "Marco"
    -$user->email = "admin@mail.com"
    -$user->password = bcrypt('123456')
    -$user->save()
    -exit
  -Se edita la función create de Admin/PostsController
    -Se agrega: $post->url = str_slug($request->get('title'));
  -Se crean 2 etiquetas manualmente desde la BD
Commit - Título y descripción para SEO
  -Se edita la vista layout.blade.php
    -Se usa la directiva @yield('') para que el título sea dinámico en cada página
      -	<title>@yield('meta-title', config('app.name') . ' | Blog')</title>
    -Se crea la etiqueta para la descripción del sitio
      <meta name="description" content="@yield('meta-description', 'Este es el blog de Zendero')">
  -Se edita la vista /posts/show.blade.php para cambiar el atributo meta-title
    -@section('meta-title', $post->title)
    -@section('meta-description', $post->excerpt)
Commit - Social links
  -Se edita el archivo public/styles.css
    -Se agrega estilos a los botones de redes sociales
  -Se edita la vista posts/show.blade.php
    -Se comodan los botones de redes sociales
    Nota: Al momento de crear este proyecto Google+ ya no está disponible pero se mantiene el link para fines prácticos
    -Se editan los href de los links de redes sociales
    Nota:Tuve un error por la url del proyecto, pero funciona correctamente con la url sin carácteres especiales
    -Funciona: https://blogudemy1.it/blog/mi-cuarto-post
    -No funciona: https://laravel5-4_blogudemy.it/blog/mi-quinto-post
    -Se corta los links de redes sociales y se pega en el partial partials/social-links.blade.php
  -Se crea el partial social-links.blade.php dentro de la carpeta resources/views/partials/
    -Se edita para que el partial sea reutilizable y no dependa de variables pasadas a través del controlador 
      -@include('partials.social-links', ['description' => $post->title])
    -Se pega el contenido cortado de la vista posts/show.blade.php
Commit - Actualizar posts
  -Se edita la vista admin/posts/index.blade.php 
    -Se agrega un botón para crear un post
      -Se agrega el modal vinculado a este botón
    -Se copian ciertas cosas de la vista admin/posts/create.blade.php
  -Se edita Admin/PostsController 
    -Se comenta la función store(sé usará más adelante en este mismo commit)
    -Se crea una nueva función store para el modal que solo requiere el title
    -Se crea la función edit 
  -Se crea la ruta admin.posts.edit en web.php dentro de las rutas admin
    -Route::get('posts/{post}', 'PostsController@edit')->name('admin.posts.edit');
  -Se crea la vista edit.blade.php dentro de resources/views/admin/
  -Se edita la migración create_posts_table para aceptar valores nulos
    -$table->mediumText('excerpt')->nullable();
    -$table->text('body')->nullable();
    -$table->unsignedInteger('category_id')->nullable();
  -Se crea un seeder para los usuarios
    -php artisan make:seed UsersTableSeeder
    -Se edita UsersTableSeeder
      Nota: Importar el modelo User
        -use App\User;
  -Se registra UsersTableSeeder en DatabaseSeeder.php
  -Se usa el comando php artisan migrate:refresh --seed
  -Se corta todo el contenido de admin/posts/create.blade.php y se pega en admin/posts/edit.blade.php
  -Se edita Admin/PostsController
    -Se pone entre comentarios la función create
    -Se copia el contenido de la función create y se pega en la función edit
    -Se edita la función edit
  -Se edita la vista admin/posts/edit.blade.php
    -Se usa casi lo mismo que en admin/posts/create
    -Se agregó un valor por defecto al método old()
      -Se hizo una condición ternearia en la función old de published_at para arreglar el error por intentar darle formato a null(osea sin fecha)
        -old('published_at', $post->published_at ? $post->published_at->format('m/d/Y') : null) }}"
    -Se edita el action del form
    -Se agrega después de csrf_field 
      -{{ method_field('PUT') }}
  -Se crea la ruta admin.posts.update en web.php dentro de las rutas admin
    -Route::put('posts/{post}', 'PostsController@update')->name('admin.posts.update');
  -Se edita Admin/PostsController cambiandole el nombre a la función comentada store por update
    -Se edita la función update
      -Se quita la instancia de nuevo Post ya que es pasada por parámetro por el modal
      -Se agrega la validación al campo tags
      -Se cambia el mensaje de la variable de sesión flash
  -Se edita PostsTableSeeder para asignar etiquetas usando seeds
    Nota: Importar el modelo Tag
      -use App\Tag;
    -Se usa en cada post para djuntar una etiqueta a cada post
      - $post->tags()->sync(Tag::create(['name' => 'Etiqueta 1']));
  -Se usa el comando php artisan migrate:refresh --seed
  -Se edita la migración create_post_tag_table quitando el campo timestamps ya que no se usa
  -Se usa el comando php artisan migrate:refresh --seed
  -Se edita la vista admin/posts/index.blade.php 
    -Se corta el modal y se pega en admin/posts/create.blade.php
  -Se edita la vista admin/partials/nav.blade.php
Commit - Subir imágenes con DrozoneJs
  -Se edita la vist a admin/posts/create.blade.php
    -Se le agrega la propiedad required al elemento title 
  -Error al momento de guardar un post porque redirige a una ruta que ya no existe porque fue cambiado el nombre del post
  Solución
  -Se edita la función update en el redirect de Admin/PostsController
    -return redirect()->route('admin.posts.edit', $post)->with('flash', 'Tu publicación ha sido guardada');
  -Se obtiene DropzoneJs del cdn del sitio web
    -https://cdnjs.com/libraries/dropzone/5.0.1 la versión minificada
    -JS
      -https://cdnjs.cloudflare.com/ajax/libs/dropzone/5.0.1/min/dropzone.min.js
    -CSS
      -https://cdnjs.cloudflare.com/ajax/libs/dropzone/5.0.1/dropzone.css
  -Se edita admin/posts/edit.blade.php 
    -Se importa DropzoneJs tanto en la directiva push de css como de js
    -Se crea el área donde se mostrarán las imágenes
    -Se crea el código javascript de dropzone para editar el mensaje, la url.
  -Se crea el modelo Photo junto con una migración y el controlador
    -php artisan make:model Photo -mc
  -Se crea la ruta para guardar las imágenes dentro del grupo de rutas admin
  Nota: Se debe mover el controlador PhotoController dentro de la carpeta de Admin
    -Se le debe cambiar el nombre al controlador por PhotosController.php
    -Se le cambia el nombre en el namespace dentro del controlador PhotosController
  -Se crea la función store dentro de PhotosController
    Nota: Importar el modelo Post
      -use App\Post;
      -use App\Http\Controllers\Controller;
      -Se le debe cambiar el namespace porque el controlador está dentro de la carpeta Admin
        -Esto: namespace App\Http\Controllers;
        -Por esto: namespace App\Http\Controllers\Admin;
Commit - Validando las imágenes con DropzoneJs
  -Se edita la vista admin/posts/edit.blade.php
    -Se le agrega la propiedad acceptedFile para indicarle que tipo de archivo es el que se va a subir
      -acceptedFiles: 'image/*',
        -Dónde el * es para permitir cuqluier extensión de imágenes
    -Se agreg la propiedad maxFilesize para indicarle el tamaño máximo permitido
      -maxFilesize: 2,
        -La cantidad está en megabytes
        -Dónde 2 debe ser el tamaño máximo del archivo imagen
    -Dropzone regresa un array con el nombre file para cambiarle el nombre se usa
      -paramName: 'photo'
    Nota: En la versión 5.4 de laravel para ver el mensaje de error es así res.photo[0];
          pero en laravel 5.7 donde se había hecho el proyecto antes tenía que ser así res.errors.photo[0];
  -Se edita la función store de Admin/PhotoController
    -Se agregan las validaciones de lado del servidor (Siempre es bueno tener otra capa de seguridad)
    -Se guarda el array photo de dropzone cambiado con paramName 
      -$photo = request()->file('photo');
Commit - Almacenando las imágenes en BD 
  -Se edita la vista admin/posts/index.blade.php 
    -Se agregan los href de los links de operaciones para mostrar(show) y editar(edit) los posts individualmente
      Nota: Faltaba un link para mostrar(show) el post y se agregó
  -Se edita web.php
    -Se le da un nombre a la ruta posts.show
  -Se edita la función store de Admin/PhotosController
    -Si se usa el helper Storage
      -use Illuminate\Support\Facades\Storage;
    Nota: Importar el modelo Photo
      -use App\Photo;
  -Se usa el comando php artisan storage:link para crear un acceso directo de la carpeta storage en la carpeta public
  -Se edita el archivo Instrucciones/Instalación.txt
  -Se edita la migración create_photos_table
    -Se agregan los campos
      $table->unsignedInteger('post_id');
      $table->string('url');
  -Se usa el comando php artisan migrate:refresh --seed
  -Se edita el modelo Photo
    -protected $guarded = false;
  -Se crea la función photos en el modelo Post que tendrá la relación hasMany() - tiene muchos
    -return $this->hasMany(Photo::class);
Commit - Mostrando las imágenes
  -Se usa el comando php artisan migrate:refresh --seed
  -Se edita la vista welcome.blade.php para mostrar las imágenes
  -Se edita la vista posts/show.blade.php para mostrar las imágenes
    -Se edita el archivo public/css/framework.css
      -Se edita la clase container quitando los padding right y left para mejorar el diseño
      Nota: Está entre comentarios /* Editado para Laravel 5.4 BlogUdemy */
    -Se edita el archivo public/css/styles.css 
      -Se edita la clase .masonry .gallery-image {}
      -Se agrega .gallery-image img {}
      -Se agrega .gallery-photos {}
      -Se agrega .overlay {} - Está clase sirve para mostrar el conteo de imágenes que hay a partir de 4 imágenes
      Nota: Está entre comentarios /* Editado para Laravel 5.4 BlogUdemy */ o /* Creado para Laravel 5.4 BlogUdemy */
    -@foreach ($post->photos->take(4) as $photo) para que solo tome 4 fotos
    -@if ($loop->iteration === 4) Hace algo cuando el foreach llega a 4