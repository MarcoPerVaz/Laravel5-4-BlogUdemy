Commit - Creación del proyecto Laravel5-4_BlogUdemy
  -composer create-project --prefer-dist laravel/laravel Laravel5-4_BlogUdemy "5.4.*"
Commit - Se crea la carpeta Instrucciones
  -Se crea el archivo Instalación.txt
  -Se crea el archivo GuíaCommits.txt
Commit - Integrando la plantilla Zendero al proyecto Laravel5-4_BlogUdemy
  -Se copian las carpetas css, img y js de la carpeta descargada(Zendero) y se pegan en public/ del proyecto Laravel5-4_BlogUdemy
  -Se copia el contenido del archivo index.html de la carpeta descargada(Zendero) y se pega en la vista welcome.blade.php
  -Se edita la vista welcome quitando las partes que se usarán en todas las vistas y se pasa a la vista layout.blade.php
    -Se usan las directivas (@extends y @section) para vincular la vista con layout.blade.php
  -Se crea la vista layout.blade.php
    -Esta vista tendrá todo lo que se repite(head, header y footer) y las demás vistas solo agregarán el contenido del post
    -Se edita la vista layout usando la directiva (yield) para vincular con la directiva section
Commit - Creando la tabla posts y BD
  -Se modifica el archivo .env
    APP_URL=https://laravel5-4_blogudemy.it/
    DB_DATABASE=laravel54blogudemy
    DB_USERNAME=root
    DB_PASSWORD=
    -La base de datos se creó desde consola
      -se usa el comando mysql -uroot
      -CREATE DATABASE laravel54blogudemy;
  -Se usa el comando php artisan migrate
  -Error si se usa MariaDB : Specified key was too long; max key length es 767 bytes
    -Solución: Ir a app/Providers/appServiceProvider.php
      -En la función boot agregar:
        -Schema::defaultStringLength(191);
        Nota: Importar el Facade 
          -use Illuminate\Support\Facades\Schema;
    Nota: Solo si hubo el error se vuelve a usar el comando php artisan migrate
  -Se usa el comando php artisan make:model Post -m para crear un modelo con su migración
    -Dónde Post es el nombre del modelo, m es migración
  -Se edita la migración create_posts_table agregando los campos
    $table->string('title');
    $table->mediumText('excerpt');
    $table->text('body');
    $table->timestamp('published_at')->nullable();
  -Se usa el comando php artisan migrate
Commit - Mostrando los posts desde la BD
  -Se crean 2 campos manualmente en la tabla Posts en la BD
    -Mi primer post -- Extracto de mi primer post -- <p>Contenido de mi primer post</p>
  -Se crea una ruta de prueba en web.php
  -Se edita la ruta por defecto en web.php
  -Se edita la vista welcome.blade.php para mostrar los Posts que fueron agregados manualmente
    Nota: Se dejaron entre comentarios los posts que no se usan todavía
    -Se edita el post con la clase post no-image
      -Se usa la directiva @foreach ($posts as $post) para mostrar todos los posts
Commit - Mostrando la fecha de publicación de los posts
   -Se edita el modelo Post agregando
    -protected $dates = ['published_at']; para decir que el campo published_at también sea una instancia de carbon la librería
  -Se edita la vista welcome para mostrar la fecha
    <span class="c-gray-1">{{ $post->published_at->format('M d') }}</span>
		<span class="c-gray-1">{{ $post->published_at->diffForHumans() }}</span>
Commit - Creando las categorías
  -Se usa el comando php artisan make:model Category -m para crear el modelo Category con su migración
  -Se edita la migración create_categories_table para agregar el campo name
    -$table->string('name');
  -Se usa el comando php artisan migrate
  -Se crea la función category en el modelo Post que tendrá la relación belongsTo() - uno a muchos
    -return $this->belongsTo(Category::class);
  -Se edita la migración create_posts_table para agregar el campo category_id después del campo published_at
    -$table->unsignedInteger('category_id');
  -Se usa el comando php artisan migrate:refresh para rehacer las tablas de la BD
  -Se vuelven a crear 2 registros manualmente en la BD en la tabla posts y 2 categorías en la tabla categories
    -Mi primer post--Extracto de mi primer post--<p>Contenido de mi primer post</p>--2019-08-05 13:17:57--2--2019-08-05 13:18:02--2019-08-05 13:18:03"
    -Mi segundo post--Extracto de mi segundo post--<p>Contenido de mi segundo post</p>--2019-08-05 13:17:57--1--2019-08-05 13:18:02--2019-08-05 13:18:03"
    -Categoría 1
    -Categoría 2
  -Se edita la vista welcome para mostrar la categoría usando la relación belongsTo
    -$post->category->name
      -Dónde $post es la variable del foreach, category es la función con belongsTo y name es el campo de la tabla categories
Commit - Implementando Seeders
  -Se crea el seeder usando el comando php artisan make:seeder PostsTableSeeder
  -Se registra PostsTableSeeder en el archivo DatabaseSeeder.php
  -Se edita la función run de PostsTableSeeder para crear posts
    Nota: No olvidar importar la clase Post y Category
      -use App\Post;
      -use App\Category;
    -Si se usa Carbon
      Nota: No olvidar importar la clase Carbon
        -use Carbon\Carbon;
  -Se usa el comando php artisan migrate:refresh para probar los seeds
  -Se usa el comando php artisan db:seed para llenar con información desde los seeders
    Nota: También se puede usar php artisan migrate:refresh --seed para refrescar las tablas y agregar los seeds
Commit - Creando las etiquetas
  -Se crea el modelo Tag con su migración usando el comando php artisan make:model Tag -m
    -Se edita la migración create_tags_table agregando el campo name
      -$table->string('name');
  -Se usa el comando php artisan migrate
  -Se crea la migración create_post_tag_table que guardará la relación belongsToMany entre posts y tags
    -php artisan make:migration create_post_tag_table --create=post_tag
      -Se agregan los campos para guardar los id's de la posts Post y la tabla tags
        $table->unsignedInteger('post_id');
        $table->unsignedInteger('tag_id');
  -Se usa el comando php artisan migrate
  -Se crean 2 registros manualmente en la BD para crear etiquetas
    -Etiqueta 1
    -Etiqueta 2
  -Se crean relaciones entre etiquetas y posts colocando los id's correspondientes de forma manual en la tabla post_tag de la BD
    -1 -- 1 .. dónde 1 es el id del post y 1 es el id del tag
    -1 -- 2 .. dónde 1 es el id del post y 2 es el id del tag
    -2 -- 1 .. dónde 2 es el id del post y 1 es el id del tag
    -3 -- 2 .. dónde 3 es el id del post y 2 es el id del tag
    -4 -- 1 .. dónde 4 es el id del post y 1 es el id del tag
    -4 -- 2 .. dónde 4 es el id del post y 2 es el id del tag
    -5 -- 1 .. dónde 5 es el id del post y 1 es el id del tag
  -Se crea la función tags en el modelo Post para hacer la relación muchos a muchos(belongsToMany)
    - return $this->belongsToMany(Tag::class);
  -Se edita la vista welcome.blade.php para mostrar las etiquetas
    -@foreach ($post->tags as $tag)
      -#{{ $tag->name }}
    -@endforeach
Commit - Integrando plantilla de administración AdminLTE
   -Se descarga la plantilla de AdminLTE 2.3.11 desde el sitio
    -https://github.com/ColorlibHQ/AdminLTE/releases/tag/v2.3.11
  -Se crea la carpeta adminlte en public/
    -Se copian dentro, las carpetas dist/css, dist/img, dist/js, bootstrap y plugins del archivo original al proyecto laravel5.4-BlogUdemy
  -Se crea la carpeta admin en resources/views/ y dentro el archivo layout.blade.php
  -Se copia el contenido del archivo starter.html y se pega en la vista layout.blade.php
  -Se edita la vista admin/layout.blade.php para modificar los href de la vista layout.blade.php para que apunten a la carpeta /adminlte/
    -En el apartado Main Content se agrega la directiva @yield('content')
  -Se crea la vista dashboard.blade.php dentro de la carpeta admin en resources/views/
  -Se edita el archivo web.php
    -Se elimina la ruta de prueba
    -Se crea la ruta admin 
Commit - Integrando el login
  -Se usa el comando php artisan make:auth --views para generar los archivos básicos para integrar el login
    -Dónde --views es un parámetro para solo crear las vistas de autenticación
  Nota: Se elimina el archivo app.css en public/css/ para igualar lo que se hace en el curso(no sé en que momento se eliminó)
  -Se copian las rutas de la función auth() que están en vendor/laravel/framework/src/Illuminate/Routing/Router.php(línea 1007)
   y se pegan en web.php
  -Se pone entre comentarios las rutas para Register
    Nota: Aparece un error de que la ruta register no está definida
    -Error: Route [register] not defined. (View: C:\laragon\www\Laravel5-4_BlogUdemy\resources\views\layouts\app.blade.php)
    Solución: Se debe editar la vista layouts.app.blade.php
      -Quitar la línea <li><a href="{{ route('register') }}">Register</a></li>
  -Se elimina la carpeta layouts que viene por defecto con el comando auth porque no se va a usar
  -Se edita la vista login en la directiva @extends para que extienda de admin.layout
  -Al final se copia todo el contenido de la plantilla Adminlte en pages/examples/login.html 
    -Se quitan las directivas extends y section y sin borrar nada se pega arriba porque se usará el código que generó el comando auth
    -Se van reemplazando cosas del código de auth al código de la plantilla de adminlte(muy extenso de documentar)
    -Se borra el código hecho por el comando auth cuando se termina de copiar al código de la plantilla admilte
    -Se actualizan las rutas de los href 
  -Se cambia el lenguaje de los mensajes de error
    -En config/app.php en la variable locale cambias de 'en' por 'es'
    -Se crea la carpeta es dentro de resources/lang 
      -Dónde 'es' es de español
    -Se copian los 4 archivos dentro de la siguiente url https://github.com/caouecs/Laravel-lang/tree/master/src/es
    -Se pegan dentro de resources/lang/es
  -Se le cambia el nombre a la aplicación desde el archivo .env en el campo APP_NAME=Zendero
  -Se le cambia el nombre a la aplicación tambien en el archivo config/app.php
    -Esto: 'name' => env('APP_NAME', 'Laravel'), por: 'name' => env('APP_NAME', 'Zendero'),
  -Se agregó un usuario usando la herramienta Tinker de laravel
    -php artisan tinker
    -$user = new App\User
    -$user->name = "Marco"
    -$user->email = "admin@mail.com"
    -$user->password = bcrypt('123456')
    -$user->save()
  -Se edita la ruta por admin cambiando admin por home
  -Se edita la vista /admin/dashboard.blade.php
    -Poniendo <p>Usuario autenticado: {{ auth()->user()->name }}</p> para comprobar si se inicio sesión
  -Se vuelve a editar la ruta admin agregandole un middleware auth
Commit - Personalizando el menú y utilizando controladores
  -Se edita la vista admin/layout.blade.php
    -Cambiando el title por  <title>{{ config('app.name') }}</title>
    -Varios cambios extenso de documentar
  -Se crea una carpeta llamada partials dentro de vies/admin/ y dentro el fragmento de visat nav.blade.php
  -Se crea la carpeta posts dentro de views/admin/ para guardar todo lo relacionado con los posts y dentro la vista index.blade.php
  -Se crea el controlador HomeController porque en mi proyecto no se genero al momento de usar el comando make:auth
    -php artisan make:controller HomeController
      -Se crea el constructor con el middleware auth
      -Se crea la función index para retornar la vista admin.dashboard
  -Se edita la ruta admin para redirigir a HomeController en su método index 
  -Se crea el controlador PagesController con el comando php artisan make:controller PagesController encargado de listar los posts
    -Se pasa lo que había en la ruta por defecto a la función home de PagesController
      Nota: Importar la clase use App\Post;
  -Se crea el controlador PostsController dentro de la carpeta Admin usando el comando php artisan make:controller Admin/PostsController
    -Se crea la función index devolviendo la vista admin.posts.index
  -Se crea un grupo de rutas para los posts si se está logueado 
Commit - Mostrando los posts en admin con Datatables
  -Se edita la ruta admin en web.php
    -Se le da un nombre a la ruta Route::get('posts', 'PostsController@index');
      -Route::get('posts', 'PostsController@index')->name('admin.posts.idex');
  -Se edita el partial admin/nav.blade.php agregando el href a ver todos los posts
    -href="{{ route('admin.posts.index') }}
  -Se edita la vista admin/layout.blade.php
    -Se corta el contenido de section page header y se cambia por la directiva @yield('header') para poder cambiarlo dependiendo la página
      -El header se agrega en el partial admin/posts/index.blade.php
      -Uno para header y otro para content
  -Para usar datatables se deben agregar los estilos y js en la vista layout.blade.php
    -Se editan los href del css y js para que vincule bien a la carpeta adminlte/
  -Se copia y edita el script de datatables que está al final del archivo pages/tables/data.html y se pega en la vista layout.blade.php
  -Se copia el datatables de pages/tables/data.html y se pega en la vista layout.blade.php
    -Se quita el contenido estático del tbody del datatable porque ahí van los posts de la BD
    -Se agrega el foreach que recorrerá los posts
  -Se edita la función index de PostsController para mandar los posts a la vista
    -$posts = Post::all();
      Nota: Importar el modelo 
        -use App\Post;
  -Se edita la vista admin/posts/index.blade.php
    -Se extiende de layout
    -Contiene 2 section(header y content)
    -Se edita el datatable para mostrar los posts y sus botones de edición y eliminación
Commit - Reestructuración de código y activación de links
  -Se edita el LoginController cambiando el redirect de /home a /admin
  -Se edita el middleware RedirectIfAuthenticated.php cambiando el redirect de /home a /admin
  -Se edita el nombre del controlador HomeController por AdminController
    -Se le cambia el nombre al archivo de HomeController.php por AdminController.php
    -Se cambia el nombre de class HomeController por class AdminController dentro del controlador
  -Se mueve el controlador AdminController a dentro de la carpeta Admin/
    -Edita el namespace del controlador AdminController
      -Esto: namespace App\Http\Controllers; por esto: namespace App\Http\Controllers\Admin; porque está dentro de la carpeta Admin
      Nota: Importar use App\Http\Controllers\Controller;
  -Se mueve la ruta admin a dentro del grupo de rutas Rutas para los posts si se está logueado
  -Se edita la ruta admin 
    -Esto: Route::get('home', 'AdminController@index'); por esto: Route::get('/', 'AdminController@index');
    -Se le da un nombre a la ruta Route::get('/', 'AdminController@index')->name('dashboard');
  -Se edita el partial nav.blade.php modificando los href y clase active para la activación de los links del menú navegación iquierdo
Commit - Creación del formulario para crear posts
  -Se crea la función create en PostsController
  -Se edita los href /admin/nav.blade.php para vincular ahacía vistas usando el herlper route('')
    -Se le agrega admin/posts* para mantener la barra de navegación desplegada {{ request()->is('admin/posts*') ?  'active' : '' }}
  -Se crea la ruta create en el grupo de rutas de admin
    -Route::get('posts/create', 'PostsController@create')->name('admin.posts.create');
  -Se crea y se edita la vista admin/posts/create.blade.php
  -Se edita la vista nav.blade.php para activar el link de navegación crear un post
  -Se editan los href de section header en los partials index.blade.php y  create.blade.php
Commit - Implementación de un selector de fechas 'datapicker'
  -Se copia el datepicker seleccionado de adminlte/pages/forms/advanced.html y se pega en la vista create.blade.php
  -Se edita la vista admin/layout.blade.php
    -Se usa la directiva @stack('') para cargar archivos solo en la vista que lo necesitemos
      -@stack('styles') para los css y para utilizar stack se usa la directiva @push en la vista donde se usen los archivos
      -@stack('scripts') para los js y para utilizar stack se usa la directiva @push en la vista donde se usen los archivos
  -Se edita la vista admin/create.blade.php
    -Se usa la directiva @push('') para elegir que archivos irán en la directiva @stack
      -Se crea la directiva @push('styles') y @push('scripts') en la vista admin/create.blade.php
    -Se editan los href y src de los archivos importados para tener bien las referencias
    -Se crea el select para las categorías
    -Se crea el botón guardar
  -Se edita la vista admin/index.blade.php
    -Se usa la directiva @push('') para elegir que archivos irán en la directiva @stack
      -Se crea la directiva @push('styles') y @push('scripts') en la vista admin/index.blade.php
    -Se editan los href y src de los archivos importados para tener bien las referencias
  -Se edita la función create de Admin/PostsController para mostrar todas las categorías en el select de la vista create.blade.php
    Nota: Importar el modelo use App\Category;
Commit - Integrando un editor de contenido y un selector múltiple
  -Se importa Ck Editor 4.6.2 dentro de la directiva push en la vista /admin/posts/create.blade.php
    -Se implementa ck editor en la directiva @push('scripts') y se hace referencia el id con el id del textarea del html
  -Se copia el contenido del select de adminlte/pages/forms/advanced.html y se pega en admin/posts/create.blade.php
    -Se pega debajo de categorías
  -Se importa Select2 dentro de la directiva push en la vista /admin/posts/create.blade.php
    -Se editan los href y src de los archivos importados para tener bien las referencias
  -Se edita la función create de Admin/PostsController para mostrar todos los tags en el select de la vista create.blade.php
    Nota: Importar el modelo use App\Tag;
Commit - Guardando las publicaciones
  -Se edita la vista admin/posts/create.blade.php
    -Se modifica el action y method del form
    -Se agrega el token csrf dentro y hasta arriba de la etiqueta form
    -Se le agrega la propiedad name="category" al elemento select de categorías
    -Se le agrega la propiedad name al elemento select de etiquetas
      Nota: Al ser un array la propiedad name debe ser name="tags[]"
  -Se edita web.php para crear la ruta admin.posts.store detro del grupo de Rutas Admin para los posts si se está logueado
  -Se edita el modelo Post para agregar la propiedad guard para que omita el error de asignación masiva
  -Se crea y edita la función store de PostsController
    Nota: Importar use Carbon\Carbon; si se usa la librería Carbon
      -Despues de guardar el post y formatear el campo published_at con Carbon
      -Se usa la relación tags que está en el modelo Post para guardar las etiquetas usando el método attach() o adjuntar en español
      -Se regresa a la página anterior con una variable de sesión que contiene el mensaje
  -Se edita la vista admin/layout.blade.php para agregar la variable de sesión flash enviada desde el controlador
  Nota: Al momento de ver los posts en https://laravel5-4_blogudemy.it/ mostró un error porque en la BD había un registro con el
        campo published_at vacío
        -Solución Agregarle una fecha al campo published_at o eliminar el registro
Commit - Validando el formulario para crear posts
  -Se edita la función create de PostsController para agregar la validación
    -Se cambia esto: $post->published_at = Carbon::parse($request->get('published_at')); 
    -Por esto: $post->published_at = $request->has('published_at') ?  Carbon::parse($request->get('published_at')) : null;
    Nota: Acá hay un error, al momento de mostrar los posts en la página principal https://laravel5-4_blogudemy.it/
          -Error: Call to a member function format() on null
            Nota:Se debe a que guarda null en el campo published_at
              Nota:Se soluciona más adelante en otro commit.
  -Se edita la vista admin/posts/create.blade.php 
    -Se muestran los errores de validación
    -Se corrigió una palabra que estaba mal escrita en el placeholder de contenido y extracto
    -Se corrigió que no mostraba el texto de placeholder en el extracto por el orden del elemento textarea en el html
      -El placeholder de body no funciona por usar CkEditor, si se quita si funciona
    -Se agrega el método old('') para que en caso de mostrar un error de validación, no se pierda la información
      Nota: El tratamiento de old para categories y tags es diferente
        -Para categories es: <option value="{{ $category->id }}" {{ old('category') == $category->id ? 'selected' : '' }}>
        -Para tags es:  <option {{ collect(old('tags'))->contains($tag->id) ? 'selected' : '' }} value="{{ $tag->id }}">{{ $tag->name }}</option>
          -Dónde collect(old('tags')) es para convertirlo en una colección
          -Dónde contains($tag->id) es para comprobar si contiene $tag->id
          -Dónde ? 'selected' : '' si lo contiene colocale la propiedad selected, de lo contrario no coloques nada
Commit - Query scopes
  -Se edita la función home de PagesController para no mostrar los posts sin fecha de publicación(published_at) o futuros
    Nota: Importar la librería carbon 
      -use Carbon\Carbon;
      Nota: Si la consulta SQL se pasa a un query scope y no se usa la librería carbon en el controlador, se puede quitar la referencia a carbon
        -Quitar: use Carbon\Carbon;
    Nota: Se soluciona el error al momento de mostrar los posts en la página principal https://laravel5-4_blogudemy.it/
      -Error: Call to a member function format() on null
        Nota:Se debe a que guarda null en el campo published_at
    -Se usa el query scope en la función home
      -$posts = Post::published()->get();
        -Dónde published() es la scope scopePublished creado en el modelo Post
  -Se crea un query scope llamado scopePublished() en el modelo Post para sustituir la búsqueda de los posts que se hace en PagesController
    Nota: Importar la librería carbon 
      -use Carbon\Carbon;
Commit - Mostrando los posts individuales
  -Se edita la vista welcome.blade.php
    -Se edita el href junto con el texto para vincular al post individual
  -Se crea el controlador PostsController que es diferente a admin/PostsController
    -Este controlador servirá para cuando no es admin
      -php artisan make:controller PostsController
    -Se crea la función show en PostsController
  -Se crea la carpeta posts en resources/views y dentro la vista show.blade.php
    -Se edita la vista show.blade.php
      -Se copia contenido de la plantilla Zendero del archivo single-post.html
        -Es extenso de documentar
    -Esta vista es para mostrar los posts individuales sin ser admin
    -Se corta el contenido de disqus que está entre la etiqueta script
      -Se crea la carpeta partials en resources/views para guardar archivos de terceros
        -Dentro se crea el archivo disqus-script.blade.php
          -Aquí se pega el contenido del script cortando anteriormente
    -Se usa la directiva @include('disqus-script') para agregar disqus a la vista show.blade.php
    -Se reemplaza el contenido estático por contenido de la BD
      -Demasiados cambios como para documentar
    -Se edita la función show de PostsController para vincular la vista con el contenido de la BD
      -$post = Post::find($id);
      Nota: Importar el modelo
        -use App\Post;
  Nota: Al mostrar el post individual hubo un error en los estilos por lo que no se mostraban
  -Se edita la vista layout.blade.php
    -Solución: A los estilos se les agregó un barra diagonal '/' a los href
    -Se agrega la directiva @stack('scripts') para vincular los css
    -Se edita el href de home del menú principal
Commit - Generando url's amigables
  -Se arregla un error con imágenes que no se mostraban en la vista posts/show.blade.php
    -Se copia la carpeta flat_web_icon_set que está en la plantilla Zendero/img y se pega en public/ del proyecto
  -Se edita la función show de PostsController para implementar Model Binding
  -Se edita web.php
    -Esto: Route::get('blog/{id}', 'PostsController@show'); por esto: Route::get('blog/{post}', 'PostsController@show');
  -Se crea la función getRouteKeyName() en el modelo Post para sobreescribir la función y que pueda mostrar otro campo diferente a id
  Nota: Para que en lugar de ver el id en la url se vea algún otro campo
  -Se crea un nuevo campo en la migración create_posts_table
    -$table->string('url');
  -Se usa el comando php artisan migrate:refresh --seed
  -Acá hubo un error ya que el campo url no tiene un valor por defecto
    -Se edita el seed PostsTableSeeder para darle un valor por defecto al campo url al crear el seed
      -Ejemplo: $post->url = str_slug("Mi primer post");
  -Se edita el href de Leer más de la vista welcome.blade.php 
    -Se cambia $post->id por $post->url
  -Se crea un usuario usando Tinker
    -php artisan tinker
    -$user = new App\User;
    -$user->name = "Marco"
    -$user->email = "admin@mail.com"
    -$user->password = bcrypt('123456')
    -$user->save()
    -exit
  -Se edita la función create de Admin/PostsController
    -Se agrega: $post->url = str_slug($request->get('title'));
  -Se crean 2 etiquetas manualmente desde la BD
Commit - Título y descripción para SEO
  -Se edita la vista layout.blade.php
    -Se usa la directiva @yield('') para que el título sea dinámico en cada página
      -	<title>@yield('meta-title', config('app.name') . ' | Blog')</title>
    -Se crea la etiqueta para la descripción del sitio
      <meta name="description" content="@yield('meta-description', 'Este es el blog de Zendero')">
  -Se edita la vista /posts/show.blade.php para cambiar el atributo meta-title
    -@section('meta-title', $post->title)
    -@section('meta-description', $post->excerpt)
Commit - Social links
  -Se edita el archivo public/styles.css
    -Se agrega estilos a los botones de redes sociales
  -Se edita la vista posts/show.blade.php
    -Se comodan los botones de redes sociales
    Nota: Al momento de crear este proyecto Google+ ya no está disponible pero se mantiene el link para fines prácticos
    -Se editan los href de los links de redes sociales
    Nota:Tuve un error por la url del proyecto, pero funciona correctamente con la url sin carácteres especiales
    -Funciona: https://blogudemy1.it/blog/mi-cuarto-post
    -No funciona: https://laravel5-4_blogudemy.it/blog/mi-quinto-post
    -Se corta los links de redes sociales y se pega en el partial partials/social-links.blade.php
  -Se crea el partial social-links.blade.php dentro de la carpeta resources/views/partials/
    -Se edita para que el partial sea reutilizable y no dependa de variables pasadas a través del controlador 
      -@include('partials.social-links', ['description' => $post->title])
    -Se pega el contenido cortado de la vista posts/show.blade.php
Commit - Actualizar posts
  -Se edita la vista admin/posts/index.blade.php 
    -Se agrega un botón para crear un post
      -Se agrega el modal vinculado a este botón
    -Se copian ciertas cosas de la vista admin/posts/create.blade.php
  -Se edita Admin/PostsController 
    -Se comenta la función store(sé usará más adelante en este mismo commit)
    -Se crea una nueva función store para el modal que solo requiere el title
    -Se crea la función edit 
  -Se crea la ruta admin.posts.edit en web.php dentro de las rutas admin
    -Route::get('posts/{post}', 'PostsController@edit')->name('admin.posts.edit');
  -Se crea la vista edit.blade.php dentro de resources/views/admin/
  -Se edita la migración create_posts_table para aceptar valores nulos
    -$table->mediumText('excerpt')->nullable();
    -$table->text('body')->nullable();
    -$table->unsignedInteger('category_id')->nullable();
  -Se crea un seeder para los usuarios
    -php artisan make:seed UsersTableSeeder
    -Se edita UsersTableSeeder
      Nota: Importar el modelo User
        -use App\User;
  -Se registra UsersTableSeeder en DatabaseSeeder.php
  -Se usa el comando php artisan migrate:refresh --seed
  -Se corta todo el contenido de admin/posts/create.blade.php y se pega en admin/posts/edit.blade.php
  -Se edita Admin/PostsController
    -Se pone entre comentarios la función create
    -Se copia el contenido de la función create y se pega en la función edit
    -Se edita la función edit
  -Se edita la vista admin/posts/edit.blade.php
    -Se usa casi lo mismo que en admin/posts/create
    -Se agregó un valor por defecto al método old()
      -Se hizo una condición ternearia en la función old de published_at para arreglar el error por intentar darle formato a null(osea sin fecha)
        -old('published_at', $post->published_at ? $post->published_at->format('m/d/Y') : null) }}"
    -Se edita el action del form
    -Se agrega después de csrf_field 
      -{{ method_field('PUT') }}
  -Se crea la ruta admin.posts.update en web.php dentro de las rutas admin
    -Route::put('posts/{post}', 'PostsController@update')->name('admin.posts.update');
  -Se edita Admin/PostsController cambiandole el nombre a la función comentada store por update
    -Se edita la función update
      -Se quita la instancia de nuevo Post ya que es pasada por parámetro por el modal
      -Se agrega la validación al campo tags
      -Se cambia el mensaje de la variable de sesión flash
  -Se edita PostsTableSeeder para asignar etiquetas usando seeds
    Nota: Importar el modelo Tag
      -use App\Tag;
    -Se usa en cada post para djuntar una etiqueta a cada post
      - $post->tags()->sync(Tag::create(['name' => 'Etiqueta 1']));
  -Se usa el comando php artisan migrate:refresh --seed
  -Se edita la migración create_post_tag_table quitando el campo timestamps ya que no se usa
  -Se usa el comando php artisan migrate:refresh --seed
  -Se edita la vista admin/posts/index.blade.php 
    -Se corta el modal y se pega en admin/posts/create.blade.php
  -Se edita la vista admin/partials/nav.blade.php
Commit - Subir imágenes con DrozoneJs
  -Se edita la vist a admin/posts/create.blade.php
    -Se le agrega la propiedad required al elemento title 
  -Error al momento de guardar un post porque redirige a una ruta que ya no existe porque fue cambiado el nombre del post
  Solución
  -Se edita la función update en el redirect de Admin/PostsController
    -return redirect()->route('admin.posts.edit', $post)->with('flash', 'Tu publicación ha sido guardada');
  -Se obtiene DropzoneJs del cdn del sitio web
    -https://cdnjs.com/libraries/dropzone/5.0.1 la versión minificada
    -JS
      -https://cdnjs.cloudflare.com/ajax/libs/dropzone/5.0.1/min/dropzone.min.js
    -CSS
      -https://cdnjs.cloudflare.com/ajax/libs/dropzone/5.0.1/dropzone.css
  -Se edita admin/posts/edit.blade.php 
    -Se importa DropzoneJs tanto en la directiva push de css como de js
    -Se crea el área donde se mostrarán las imágenes
    -Se crea el código javascript de dropzone para editar el mensaje, la url.
  -Se crea el modelo Photo junto con una migración y el controlador
    -php artisan make:model Photo -mc
  -Se crea la ruta para guardar las imágenes dentro del grupo de rutas admin
  Nota: Se debe mover el controlador PhotoController dentro de la carpeta de Admin
    -Se le debe cambiar el nombre al controlador por PhotosController.php
    -Se le cambia el nombre en el namespace dentro del controlador PhotosController
  -Se crea la función store dentro de PhotosController
    Nota: Importar el modelo Post
      -use App\Post;
      -use App\Http\Controllers\Controller;
      -Se le debe cambiar el namespace porque el controlador está dentro de la carpeta Admin
        -Esto: namespace App\Http\Controllers;
        -Por esto: namespace App\Http\Controllers\Admin;
Commit - Validando las imágenes con DropzoneJs
  -Se edita la vista admin/posts/edit.blade.php
    -Se le agrega la propiedad acceptedFile para indicarle que tipo de archivo es el que se va a subir
      -acceptedFiles: 'image/*',
        -Dónde el * es para permitir cuqluier extensión de imágenes
    -Se agreg la propiedad maxFilesize para indicarle el tamaño máximo permitido
      -maxFilesize: 2,
        -La cantidad está en megabytes
        -Dónde 2 debe ser el tamaño máximo del archivo imagen
    -Dropzone regresa un array con el nombre file para cambiarle el nombre se usa
      -paramName: 'photo'
    Nota: En la versión 5.4 de laravel para ver el mensaje de error es así res.photo[0];
          pero en laravel 5.7 donde se había hecho el proyecto antes tenía que ser así res.errors.photo[0];
  -Se edita la función store de Admin/PhotoController
    -Se agregan las validaciones de lado del servidor (Siempre es bueno tener otra capa de seguridad)
    -Se guarda el array photo de dropzone cambiado con paramName 
      -$photo = request()->file('photo');
Commit - Almacenando las imágenes en BD 
  -Se edita la vista admin/posts/index.blade.php 
    -Se agregan los href de los links de operaciones para mostrar(show) y editar(edit) los posts individualmente
      Nota: Faltaba un link para mostrar(show) el post y se agregó
  -Se edita web.php
    -Se le da un nombre a la ruta posts.show
  -Se edita la función store de Admin/PhotosController
    -Si se usa el helper Storage
      -use Illuminate\Support\Facades\Storage;
    Nota: Importar el modelo Photo
      -use App\Photo;
  -Se usa el comando php artisan storage:link para crear un acceso directo de la carpeta storage en la carpeta public
  -Se edita el archivo Instrucciones/Instalación.txt
  -Se edita la migración create_photos_table
    -Se agregan los campos
      $table->unsignedInteger('post_id');
      $table->string('url');
  -Se usa el comando php artisan migrate:refresh --seed
  -Se edita el modelo Photo
    -protected $guarded = false;
  -Se crea la función photos en el modelo Post que tendrá la relación hasMany() - tiene muchos
    -return $this->hasMany(Photo::class);
Commit - Mostrando las imágenes
  -Se usa el comando php artisan migrate:refresh --seed
  -Se edita la vista welcome.blade.php para mostrar las imágenes
  -Se edita la vista posts/show.blade.php para mostrar las imágenes
    -Se edita el archivo public/css/framework.css
      -Se edita la clase container quitando los padding right y left para mejorar el diseño
      Nota: Está entre comentarios /* Editado para Laravel 5.4 BlogUdemy */
    -Se edita el archivo public/css/styles.css 
      -Se edita la clase .masonry .gallery-image {}
      -Se agrega .gallery-image img {}
      -Se agrega .gallery-photos {}
      -Se agrega .overlay {} - Está clase sirve para mostrar el conteo de imágenes que hay a partir de 4 imágenes
      Nota: Está entre comentarios /* Editado para Laravel 5.4 BlogUdemy */ o /* Creado para Laravel 5.4 BlogUdemy */
    -@foreach ($post->photos->take(4) as $photo) para que solo tome 4 fotos
    -@if ($loop->iteration === 4) Hace algo cuando el foreach llega a 4
Commit - Galería de fotos
  -Se edita la vista posts/show.blade.php 
    -Se usa la directiva @elseif($post->photos->count() > 1) para hacer algo si hay más de una imagen
      -Se usa la directiva @include('posts.carousel')
    -Se crea la vista carousel.blade.php dentro de resources/views/posts/
      -Se edita la vista /posts/carousel.blade.php
        -Se agrega el carousel dentro de la vista para después ser incluido en la directiva @elseif() de posts/show.blade.php
        Nota: Se usa Bootstrap 3.3.7 usando la herramienta customize, donde se selecciona lo que se quiere para compilar y descargar    
          -Desde el sitio web: https://getbootstrap.com/docs/3.4/customize/
            -Less files: 
              -Component animations (for JS) (includes collapse)
              -Carousel
            -jQuery plugins
              -Carousel functionality
              -Transitions (required for any kind of animation)
        Nota: No se puede customizar la versión 3.3.7 ya que reedirige a la versión 3.4
        Nota:Se descarga una carpeta comprimida con el nombre de bootstrap.zip se descomprime 
          Nota: Se copia el archivo js/bootstrap.js y se pega en public/js cambiandole el nombre por twitter-bootstrap.js
          Nota: Se copia el archivo css/bootstrap.css y se pega en public/css cambiandole el nombre por twitter-bootstrap.css
        -Se importa twitter-bootstrap en la directiva push de la vista post/show.blade.php
  -Se edita la vista layout.blade.php
    Nota: En el curso no tenía la directiva stack, mientras que en mi proyecto si la tenía
    -Se usa la directiva stack para los estilos 
      @stack('styles')
    -Se mueve la directiva stack de scripts al final del body ya que en el proyecto estaba en el head
      @stack('scripts')
  -Se edita el archivo public/css/styles.css para modificar el carousel de imágenes
Commit - Eliminando imágenes
  -Se edita admin/posts/edit.blade.php para mostrar las imágenes y poder borrarlas
    -Se agrega una configuración a CKEDITOR para aumentar su alto
  -Se crea la ruta admin.photos.destroy dentro de las rutas de admin
    -Route::delete('photos/{photo}', 'PhotosController@destroy')->name('admin.photos.destroy');
  -Se crea y se edita la función destroy en Admin/PhotosController
Commit - Posts con vídeo y audio
  -Se edita la vista welcome.blade.php
    -Se agrega un elseif para comprobar que si no tiene imágenes, muestre el vídeo del post
      -@elseif($post->iframe)
        -Dónde iframe se va a crear en la migración create_posts_table
    Nota: El iframe se guardará en la BD con todo y etiquetas iframe
    -Para mostrar el iframe guardado en la base de datos
      -{!! $post->iframe !!} 
        -Dónde al usar {!!  !!} permite insertar html en la vista
  -Se edita la migración create_posts_table
    -Después del campo excerpt se agrega el campo iframe
      -$table->text('iframe')->nullable();
  -Se usa el comando php artisan migrate:refresh --seed
  -Se agregaron unos comentarios en el archivo public/css/responsive.css
    -La clase .video iframe también será usada para los posts con audio
  -Se edita la vista admin/posts/edit.blade.php
    -Se crea el área para colocar el iframe(después del campo body)
  -Se edita Admin/PostsController
    -Se edita la función update para agregar el campo iframe
  Nota: Al agregar un iframe sea vídeo o audio, considerar el tamaño width: 100%; y height:480px;
  -Se edita la vista posts/show.blade.php
    -Se agrega el área para mostrar el iframe del post si es que tiene
Commit - Paginación personalizada
  -Se edita la función home de PagesController
  -Se edita la vista welcome.blade.php
    -Se quitan los posts que estaba entre comentarios
  -Se usa el comando php artisan vendor:publish --tag=laravel-pagination
    -Este comando publica las vistas de la paginación usada por laravel y así poder editar al gusto
  -Se edita la vista default.blade.php que está en resources/views/pagination/
    -Esta vista se crea al usar el comando php artisan vendor:publish --tag=laravel-pagination
    -Se adapta la paginación de default.blade.php por lo que tiene la plantilla Zendero en la vista welcome.blade.php
      Nota: Tan pronto se adapta, se borra lo que tenía la plantilla Zendero en su paginación
      -Se usan comentarios para indicar que cambios se hicieron
        -{{-- Se agrego este div con la clase pagination Laravel5.4 BlogUdemy --}}
        -{{-- Se agregaron estas clases (todas) Laravel5.4 BlogUdemy --}}
        -{{-- Se agrego la clase pagination-active y se cambio la etiqueta span por a --}}
          Nota: Este comentario es de la línea de abajo pero por esapcio se puso arriba
Commit - Filtrar posts por categoría
  -Se crea el controlador usando el comando php artisan make:controller CategoriesController
    -Se crea la función show dentro de CategoriesController
  -Se elimina la vista home.blade.php
  -Se crea la ruta categories.show en web.php
    -Route::get('categories/{category}', 'CategoriesController@show')->name('categories.show');
  -Se crea la función getRouteKeyName() en el modelo Category
  -Se edita la vista welcome.blade.php
    -Se agrega la etiqueta a en las categorías
    -Se edita el archivo public/css/styles.css
      -Se edita la clase .post .category a{}
       Nota: Está entre comentarios /* Creado para Laravel 5.4 BlogUdemy */
  -Se crea la función posts en el modelo Category para relacionar las categorías con los posts (Tiene muchos - hasMany)
    -return $this->hasMany(Post::class);
Commit - Filtrar posts por etiqueta
  -Se edita la vista welcome.blade.php
    -Se agrega la etiqueta a en las etiquetas
    -Se edita el archivo style.css
      -Se edita la clase .post .tag a{}
       Nota: Está entre comentarios /* Creado para Laravel 5.4 BlogUdemy */
  -Se crea la ruta tags.show en web.php
    -Route::get('tags/{tag}', 'TagsController@show')->name('tags.show');
  -Se crea el controlador TagsController usando el comando php artisan make:controller TagsController
    -Se crea y se edita la función show en TagsController
      Nota: Importar el modelo Tag
        -use App\Tag;
  -Se crea la función getRouteKeyName() en el modelo Tag
  -Se crea la función posts en el modelo Tag para relacionar las etiquetas con los posts (Pertenece a muchos - hasMany)
    -return $this->hasMany(Post::class);
  -Se edita la función show de CategoriesController
Commit - Accesores y mutadores de Eloquent
  -Se edita el modelo Category
    -Se crea el mutator llamado setNameAttribute()
    Nota: Checar la documentación
      -https://laravel.com/docs/5.4/eloquent-mutators#accessors-and-mutators
  -Se edita la migración create_categories_table
    -Se agrega el campo después del campo name
      -$table->string('url')->nullable;
  -Se usa el comando php artisan migrate:refresh --seed
    Nota: Se le agrega temporalmente el método nullable al campo url, se usa el comando migrate:refresh y se le quita el método al campo url
  Nota: El mutador se ejecuta automáticamente
  -Se edita la migración create_tags_table
    -Se agrega el campo después del campo name
      -$table->string('url')->nullable;
  -Se usa el comando php artisan migrate:refresh --seed
  Nota: El mutador se ejecuta automáticamente
   -Se edita el modelo Tag
    -Se crea el mutator llamado setNameAttribute()
    Nota: Checar la documentación
      -https://laravel.com/docs/5.4/eloquent-mutators#accessors-and-mutators
  -Se usa el comando php artisan migrate:refresh --seed
  Nota: El mutador se ejecuta automáticamente
  -Se edita el modelo Post para usar mutadores
    -Se crea el mutator setTitleAttribute
  -Se edita la función update y store de Admin/PostsController
Commit - Creando categorías y etiquetas sobre la marcha
  -Se edita la vista admin/posts/edit.blade.php
    -Se le agrega la clase select2 a las catgeorías y se modifica el script de select2
  -Se edita la función update de Admin/PostsController
  -Se edita el modelo Category 
    -Se agrega la propiedad protected guarded para deshabilitar la asignación masiva 
  -Se edita el modelo Tag 
    -Se agrega la propiedad protected guarded para deshabilitar la asignación masiva 
Commit - Reestructuración de Admin/PostsController
  -Se usa el comando php artisan make:request StorePostRequest
  Nota: Al usar el comando para crear un request, si no existe ningún request, laravel crea la carpeta app/Http/Requests y dentro el request creado
  Nota: Request es creado para almacenar las validaciones
  -Se edita el request StorePostRequest
    -Se cambia esto return false; por esto return true;
    -Se edita la función rules donde irán las validaciones
    -Se pasa el formRequest StorePostRequest por parámetro en la función update de Admin/PostsController
    Nota: Importar el request
      -use App\Http\Requests\StorePostRequest;
    -Se edita el modelo Post para crear mutadores
      -Se crea el mutator setPublishedAtAttribute 
      -Se crea el mutator setCategoryIdAttribute 
      -Se crea la función syncTags que tendrá la lógica que antes estaba en la función update de Admin/PostsController para 
       guardar etiquetas
      -Se quita la propiedad guarded para deshabilitar la protección de asignación masiva
      -Se agrega la propiedad fillable para protección de asignación masiva
  -Se edita la vista admin/posts/edit.blade.php 
    -Se edita el área de categorias cambiando todo de 'category' a 'category_id'
  -Se edita StorePostRequest
    -Cambiando la validación de category por category_id
Commit - Reestructuración de Admin/PhotosController
  -Se edita la función store de Admin/PhotosController
    Nota:No salió igual que en el curso
      -Curso: 'url' => request()->file('photo')->store('posts', 'public'),
      -Proyecto: 'url' => Storage::url(request()->file('photo')->store('posts', 'public')),
      Nota: En el curso el podía acceder https://blog.dev/posts/imagen.jpg y yo no pude acceder así, 
        yo accedo con https://blog.dev/storage/posts/imagen.jpg
      -Se tuvo que dejar pero funciona igual.
  -Se edito la vista posts/show.blade.php para agregar el helper url
    -<figure><img src="{{ url($post->photos->first()->url) }}" alt="" class="img-responsive"></figure>
  -Se edita el modelo Photo
    -Se crea una función estática para que elimine de la carpeta Storage la o las imágenes
      Nota:Reemplaza lo que está entre comentarios en el controlador Admin/PhotosController
      Nota: Importar el Facade
        -use Illuminate\Support\Facades\Storage;
  -Se edita PostsTableSeeder para eliminar las imágenes de Storage al usar el comando php artisan migrate:refresh --seed
    -Storage::disk('public')->deleteDirectory('posts');
    Nota: Dónde public es la configuración de config/filesystems.php y deleteDirectory es la carpeta que se va a eliminar
      Nota:Importar el Facade
        -use Illuminate\Support\Facades\Storage;
  -Se usa el comando php artisan migrate:refresh --seed 
    Nota: Se comprueba si la carpeta posts dentro de Storage/app/ se borra(Si se borra)
Commit - Eliminar posts y sus relaciones
  -Se edita la vista admin/posts/index.blade.php
    -Se agrega la etiqueta al form al botón de eliminar
  -Se crea la ruta admin.posts.destroy dentro de las rutas de admin
    -Route::delete('posts/{post}', 'PostsController@destroy')->name('admin.posts.destroy');
  -Se crea la función destroy en Admin/PostsController
  -Se crea la función boot con la función estática deleting en el modelo Post 
  -Se usa el comando php artisan migrate:refresh --seed para probar si se eliminan las etiquetas correctamente
Commit - Actualizando a Laravel 5.5
  -Se usa el comando composer global update
  -Se usa el comando composer self-update
  -Editar el archivo composer.json
    -Actualizar el framework a 5.5.*
      -"laravel/framework": "5.5.*",
    -Actualizar phpunit/phpunit a ~6.0
      -"phpunit/phpunit": "~6.0",
    -Agregar filp/whoops en su versión ~2.0
      -"filp/whoops": "~2.0"
  -Usar el comando composer update
Commit - Mantener el modal si hay errores
  -Se edita la vista admin/layout.blade.php
    -Se usa la directiva unless para verificar que el modal solo se abra dependiendo la url admin/posts/*
      -Donde * es todo lo que venga después de /
    -Dentro de la directiva unless se incluye la vista del modal @include('admin.posts.create') 
  -Se edita la vista admin/posts/create.blade.php
    -Se le quita la propiedad required al campo title
      Nota: Al final se pone de nuevo
    -Se modifica la ruta del formulario para pasar #create en la url
    -Se le da un id al campo title
    -Se le agrega la propiedad autofocus al campo title
    -Se usa la directiva push con el script para verificar si el modal está abierto
  -Se edita la función store de Admin/PostsController
    -Se agrega una regla de validación al campo title
      -$this->validate($request, ['title' => 'required|min:3']);
  -Se edita la vista admin/partials/nav.blade.php
    -Se le agrega la directiva condicional if para redireccionar dependiendo en que url tenga
Commit - Generando URL's únicas
  -Se edita el modelo Post 
    -Se comenta el mutador setTitleAttribute ya que no se va usar
    -Se crean 2 funciones 
      -Funcíon create que sobreescribe al método create que está en el controlador
      -Función generateUrl encargada de generar la url dinámica hacía la función create
  -Se edita Admin/PostsController
  -Se edita la migración create_posts_table
    -Se edita el campo url
      -Esto $table->string('url'); por esto: $table->string('url')->unique()->nullable;
  -Se usa el comando php artisan migrate:refresh --seed
Commit - Activando la navegación
  -Se Crean las rutas para el menú de navegación en web.php
    -Route::get('/', 'PagesController@home')->name('pages.home');
    -Route::get('nosotros', 'PagesController@about')->name('pages.about');
    -Route::get('archivo', 'PagesController@archive')->name('pages.archive');
    -Route::get('contacto', 'PagesController@contact')->name('pages.contact');
  -Se edita la vista layout.blade.php
    -Se extrae toda la etiqueta nav y se hace un @include('partials.nav') que será la vista de la navegación
  -Se edita la vista partials/nav.blade.php
    -Se usa el helper route para enlazar los href con las rutas 
    -Se crea un helper
  -Se edita el controlador PagesController
    -Se crea la función about
    -Se crea la función archive
    -Se crea la función contact
  -Se crea la carpeta pages en resources/views y dentro las vistas about.blade.php, archive.blade.php y contact.blade.php
  -Se mueve la vista welcome.blade.php a la carpeta resources/vews/pages y se renombra a home.blade.php
  -Se crea el archivo helpers.php en app/Http/
    -Para poderlo usar se debe agregar en composer.json
      -"files": ["app/Http/helpers.php"]
    -Se usa el comando composer dumpautoload -o
Commit - Agregando las páginas estáticas del menú
  -Se copia contenido de la plantilla Zendero del archivo about.html y se pega en la vista pages/about.blade.php
  -Se copia contenido de la plantilla Zendero del archivo archive.html y se pega en la vista pages/archive.blade.php
  -Se copia contenido de la plantilla Zendero del archivo contact.html y se pega en la vista pages/contact.blade.php
  -Se edita CategoriesController para cambiar welcome por pages.home ya que se le cambió el nombre
  -Se edita TagsController para cambiar welcome por pages.home ya que se le cambió el nombre
  -Se edita el archivo public/css/twitter-bootstrap.css 
    -se quita todo antes de la clase carousel
Commit - Acceso a posts no públicos
  -Se edita la vista posts/show.blade.php
    -Se le agrega el helper optional para poder ver el post desde admin, ya que sin fecha mostraba error 
     de que no se le puede dar formato si el valor es null 
      -<span class="c-gris">{{ optional($post->published_at)->format('M d') }}</span>
			-<span class="c-gris">- {{ optional($post->published_at)->diffForHumans() }}</span>
    -Se agrega la directiva @if para comprobar si $post->category tiene un valor porque mostraba un error 
     si el post no tenía categoría
  -Se edita la función show de PostsController
  -Se crea la función isPublished() en el modelo Post
  -Se crea la carpeta errors en resources/views y dentro se crea la vista 404.blade.php
    -Se edita la vista 404.blade.php
Commit - Asignar posts a usuarios
  -Se edita la migración create_posts_table
    -Se agrega el campo user_id después de category_id
      $table->unsignedInteger('user_id');
  -Se edita la función store de Admin/PostsController
  -Se edita PostsTableSeeder
    -Se agrega a los posts
      -$post->user_id = 1;
  -Se usa el comando php artisan migrate:refresh --seed
  -Se edita el modelo Post
    -Se agrega el campo user_id a la propiedad fillable
  -Se edita el modelo User
    -Se crea la función posts para indicar la relación hasMany
  -Se edita el modelo Post
    -Se crea la función owner para indicar la relación belongsTo
      -return $this->belongsTo(User::class, 'user_id');
        -Dónde 'user_id' es el campo que va referenciado porque de lo contrario buscaría el campo 'owner_id' por convención
  -Se edita la vista pages/home.blade.php para mostrar al creador del post
Commit - Reestructuración de vistas
  -Se edita la vista posts/show.blade.php
    -Se corta el contenido de la etiqueta header
    -Se usa la directiva @include para vincular con la vista posts/header.blade.php
    -Se usa la directiva @include para vincular con la vista posts/tags.blade.php
    -Se usa la directiva @include para vincular con la vista posts/photo.blade.php
    -Se usa la directiva @include para vincular con la vista posts/iframe.blade.php
  -Se edita la vista home.blade.php
    -Se quita el contenido de la etiqueta header
    -Se usa el helper route en el href de leer más
    -Se corta el área de las etiquetas y se pega en la vista posts/tags.blade.php
    -Se usa la directiva @include para vincular con la vista posts/header.blade.php
    -Se usa la directiva @include para vincular con la vista posts/tags.blade.php
    -Se corta el contenido dentro de elseif($post->photos->count() > 1) para pasarse a la vista carousel-preview.blade.php
    -Se corta el contenido dentro de @if ($post->photos->count() === 1) para pasarse a la vista posts/photo.blade.php
    -Se usa la directiva @include para vincular con la vista posts/photo.blade.php
    -Se corta el contenido dentro de @elseif($post->iframe) para pasarse a la vista posts/iframe.blade.php
    -Se usa la directiva @include para vincular con la vista posts/iframe.blade.php
  -Se crea la vista header.blade.php en resources/views/posts/
    -Se pega el header en la vista posts/header.blade.php, el que fue cortado de la vista posts/show.blade.php
  -Se crea la vista tags.blade.php en resources/views/posts/
    -Se pega el área de las etiquetas que fue cortado de la vista home.blade.php y se pega en posts.tags
  -Se crea la vista carousel-preview.blade.php en resources/views/posts/
    -Se pega el contenido cortado de la vista home.blade.php
  -Se crea la vista photo.blade.php en resources/views/posts/
    -Se pega el contenido cortado de la vista home.blade.php
  -Se crea la vista iframe.blade.php en resources/views/posts/
    -Se pega el contenido cortado de la vista home.blade.php
Commit - Vistas polimórficas
  -Se crea la función viewType() en el modelo post que servirá para integrar las vistas polimórficas
  -Se crea la vista text.blade.php dentro de resources/views/posts/
    -Se mantiene en blanco
  -Se edita la vista posts/home.blade.php
    -Se agrega la función viewType() dentro de <article class="post">
    -Se quitan los las directiva
  -Se edita la vista posts/show.blade.php
    -Se agrega la función viewType() dentro de <article class="post">
    -Se quitan los las directivas 
Commit - Políticas de acceso a publicaciones
  -Se edita UsersTableSeeder
    -Se agrega un nuevo usuario
  -Se edita PostsTableSeeder
    -Se cambia que el user_id del post 3 y 4 sean para el usuario 2 recien creado en UsersTableSeeder
  -Se usa el comando php artisan migrate:fresh --seed
  -Se edita la función index de Admin/PostsController
    -Se muestran solo los posts del usuario logueado
      -Forma 1: $posts = Post::where('user_id', auth()->id())->get();
      -Forma 2: $posts = auth()->user()->posts;
  -Se edita la vista admin/layout.blade.php para implementar el cierre de sesión y quitar ciertas cosas que no se van a usar
  -Se usa el comando php artisan make:policy PostPolicy -m Post para implementar las políticas
    -Dónde -m es para vincular la política a un modelo y Post el modelo a vincular
    -Se edita la función view que es la que sirve para ver un post
      -return $user->id === $post->user_id;
  -Se edita la función edit de Admin/PostsController
    -$this->authorize('view', $post);
      -Dónde view es la función de PostPolicy
  -Se edita el archivo AuthServiceProvider.php que está en app/Providers/AuthServiceProvider.php
    -Se agrega  'App\Post' => 'App\Policies\PostPolicy', en la propiedad $policies 
  -Se crea y se edita la vista 403.blade.php en resources/views/errors/ para mostrar la vista de sitio no autorizado
  -Se edita la función update de PostPolicy
    -return $user->id === $post->user_id;
  -Se edita la función update de Admin/PostsController para autorizar a la función update de PostPolicy
    -Se agrega $this->authorize('update', $post);
      -Dónde update es la función de PostPolicy
  -Se reestructura la función edit de Admin/PostsController
  -Se reestructura la función store de Admin/PostsController
  -Se edita la función create en el modelo Post
  -Se edita la función create de PostPolicy
    -return true;
  -Se edita la función store de Admin/PostsController para autorizar a la función create de PostPolicy
    - $this->authorize('create', new Post);
      -Dónde create es la función de PostPolicy
  -Se edita la función destro de Admin/PostsController
    -$this->authorize('delete', $post);
      -Dónde delete es la función de PostPolicy
Commit - Instalando el paquete laravel-permission
  -Se usa el comando composer require spatie/laravel-permission sacado del sitio web
    -https://docs.spatie.be/laravel-permission/v2/installation-laravel/
  -Se actualizan las dependencias de composer
    -Se copian los scripts de composer.json del repositorio de laravel con el branch 5.5 del sitio
      -https://github.com/laravel/laravel/tree/5.5
      -Se reemplaza por los scripts del composer.json del proyecto
    -Se copia el array config de composer.json del repositorio de laravel con el branch 5.5 del sitio
      -https://github.com/laravel/laravel/tree/5.5
      -Se reemplaza por el array de config de composer.json del proyecto
    -Se copia el array extra de composer.json del repositorio de laravel
      -Se pega el array extra en composer.json del proyecto
    -Se copia el array classmap de composer.json del repositorio de laravel con el branch 5.5 del sitio
      -https://github.com/laravel/laravel/tree/5.5
      -Se reemplaza por el classmap de composer.json del proyecto
    -Se usa el comando composer update
  -Se deb usar el siguiente comando para publicar las migraciones de laravel-permission
    -php artisan vendor:publish --provider="Spatie\Permission\PermissionServiceProvider" --tag="migrations"
    Nota: Crea la migración create_permission_tables
  -Se usa el comando php artisan migrate
  -Se edita el modelo User
    -Se agrega el trait 
      -use Spatie\Permission\Traits\HasRoles;
Commit - Roles y usuarios
  -Se usa tinker
    -Se crea un role
      -php artisan tinker
      -use Spatie\Permission\Models\Role;
      -$adminRole = Role::create(['name' => 'Admin'])
    -Se obtiene el primer usuario
      $u = App\User::first()
    -Se asigna el role 
      Nota: Se puede usar la función assignRole() porque se importó el trait use HasRoles en el modelo User
        -HasRoles se puede usar por el namespace de use Spatie\Permission\Traits\HasRoles;
      -$u->assignRole($adminRole)
    -Para preguntar si un usuario tiene role específico
      -$u->hasRole('Admin')  
        Nota: Si devuelve true es que tiene el role asignado
        Nota: Si se pregunta por un role no asignado o que no existe regresa false
          -$u->hasRole('Writer')
  -Se edita UsersTableSeeder para agregar roles a los usuarios
    -Se importa el namespace use Spatie\Permission\Models\Role;
    -Se limpia la tabla roles cada que se usa migrate:refresh
      -Role::truncate();
    -Se crean 2 roles
      -$adminRole = Role::create(['name' => 'Admin']);
      -$writerRole = Role::create(['name' => 'Writer']);
    -Se edita el usuario 1 cambiando el nombre de la variable para tener mejor referencia de que será admin
    -Se le asigna el role admin al usuario 1
      -$admin->assignRole($adminRole);
    -Se edita el usuario 2 cambiando el nombre de la variable para tener mejor referencia de que será writer
    -Se le asigna el role writer al usuario 2
      -$admin->assignRole($writerRole);
  Nota: Para poder limpiar la tabla roles 
    -Se edita el archivo DatabaseSeeder.php en database/seeds
      -Para deshabilitar la revisión de llaves foráneas
        -DB::statement('SET FOREIGN_KEY_CHECKS=0');
      -Para habilitar la revisión de llaves foráneas
        -DB::statement('SET FOREIGN_KEY_CHECKS=1');
  -Se usa el comando php artisan migrate:fresh --seed
  -Se edita la función index de Admin/PostsController
  -Se edita el modelo Post
    -Se crea una función Scope llamada scopeAllowed para verificar que posts puede ver el usuario dependiendo el Role
  -Se edita PostPolicy
    -Se crea la función before que se ejecuta antes que cualquier otra función de PostPolicy
Commit - Permisos de usuario
  -Se edita la vista admin/layout.blade.php
  -Se corrigió un error en UsersTableSeeder al asignar el role de writer, la variable se cambio de $admin por $writer
    -Esto: $admin->assignRole($writerRole); por: $writer->assignRole($writerRole);
    -Usar el comando php artisan migrate:fresh --seed
  -Se usa Tinker para manipular permisos
    -php artisan tinker
    -use Spatie\Permission\Models\Permission;
    -$permission = Permission::create(['name' => 'View posts'])
      Nota: Los permisos se leen así Permission::create(['name' => 'Ver post'])
        -Dónde se crea el permiso en la BD y en el campo name lo que permitirá ese permiso
    -use Spatie\Permission\Models\Role;
    -$roleAdmin = Role::find(1)
    -$roleAdmin->givePermissionTo($permission)
      Nota: Dónde role es lo que tiene Role::find(1)
      Nota: Dónde givePermissionTo es para darPermisoPara()
      Nota: Dónde $permission es el role creado
        -Permission::create(['name' => 'View posts'])
    -$u = App\User::find(1)
    -$u->hasPermissionTo('View posts');
      Nota: Dónde hasPermissionTo() es para preguntar siTienesPermisoPara()
      Nota: Dónde View posts es el permiso creado 
        -Permission::create(['name' => 'View posts'])
        Nota: Si devuelve true es que el usuario tiene el permiso
    -Nos salimos de Tinker con el comando exit y se usa el comando php artisan migrate:fresh --seed
  -Se usa tinker de nuevo con el comando php artisan tinker 
    -use Spatie\Permission\Models\Permission;
    -$permission = Permission::create(['name' => 'View posts'])
    -$u = App\User::find(1)
    -$u->givePermissionTo('View posts')
    -$u->hasPermissionTo('View posts');
      Nota: Dónde hasPermissionTo() es para preguntar siTienesPermisoPara()
      Nota: Dónde View posts es el permiso creado 
        -Permission::create(['name' => 'View posts'])
        Nota: Si devuelve true es que el usuario tiene el permiso, de lo contrario un error
    -Nos salimos de tinker con el comando exit
  -Se edita UsersTableSeeder
    -Se importa el namespace use Spatie\Permission\Models\Permission;
    -Se limpia la tabla de permisos al usar migrate:refresh
      -Permission::truncate();
    -Se crea el permiso View posts 
      -$viewPostsPermission = Permission::create(['name' => 'View posts']);
  -Se usa el comando php artisan migrate:fresh --seed
  -Se edita Admin/PostsController
  -Se edita la función scope scopeAllowed() del modelo Post
  -Se edita la función view de PostPolicy
  -Se usa Tinker para dar permisos al usuario
    -php artisan tinker
    -$user = App\User::find(2)
    -$user->givePermissionTo('View posts)
    Nota:Funciona agregando el permiso (Se comprobó en el navegador)
    -use Spatie\Permission\Models\Role;
    -$role = Role::find(2)
    -$role->givePermissionTo('View posts')
    -Se usa el comando exit para salir de Tinker
    -Se usa el comando php artisan migrate:fresh --seed
  -Se editan las funciones create, update y delete de PostPolicy
    -La función edit usa la función update de PostPolicy
      -$this->authorize('update', $post);
  -Se edita UsersTableSeeder para agregar 3 permisos más
    -$createPostsPermission = Permission::create(['name' => 'Create posts']);
    -$updatePostsPermission = Permission::create(['name' => 'Update posts']);
    -$deletePostsPermission = Permission::create(['name' => 'Delete posts']);
  -Se usa tinker para dar permisos al role writer
    -php artisan tinker
    -$writer = App\User::find(2)
    -$writer->givePermissionTo('Update posts')
    -Se usa el comando exit para salir de tinker
    -Se usa el comando php artisan migrate:fresh --seed
Commit - Mostrando el listado de usuarios
  -Se edita el archivo web.php
    -Se cambian las 6 rutas del grupo de admin (index, create, store, edit, update y destroy) por
      -Route::resource('posts', 'PostsController', ['except' => 'show', 'as' => 'admin']);
        -Dónde except es para que imita la ruta show
        -Dónde as es para que los nombres de las rutas empiecen con admin.
          -Ejemplo: admin.posts.index
  -Se crea la ruta users dentro del grupo de rutas de Admin
    -Route::resource('users', 'UsersController', ['as' => 'admin']);
  -Se crea el controlador UsersController dentro de la carpeta Admin usando el comando php artisan make:controller Admin/UsersController -r
    -Dónde -r es para crear la estructura de los 7 métodos REST (index, create, store, show, edit, update, destroy)
  -Se edita Admin/UsersController
    -Se edita la función index de Admin/UsersController
      Nota: Importar el namespace use App\User;
  -Se crea la carpeta users en resources/views/admin/
    -Se crea y se edita la vista index.blade.php en admin/users/
      -Se copia todo de la vista admin/posts/index.blade.php y se pega en users/index.blade.php
        -Se reemplaza el contenido para mostrar a los usuarios
        Nota: <td>{{ $user->getRoleNames()->implode(', ') }}</td>
          -Dónde getRoleNames() es parte del paquete laravel-permission y obtiene el campo name de la tabla roles
          -Dónde implode agrega una coma y un espacio por cada role que encuentra
Commit - Creando el perfil de usuario
  -Se edita la vista admin/users/index.blade.php para quitar la propiedad target="_blank" del href de admin.users.show
  -Se edita la función show de Admin/UsersController
  -Se crea la vista admin/users/show.blade.php
    -Se edita la vista admin/users/show.blade.php
  Nota: Tuve que editar la vista admin/layout.blade.php por un error al momento de dejar al usuario 2 sin role
    Nota: Esta entre comentarios {{-- Agregado por mi --}}
Commit - Editar usuarios
  -Se edita la función edit de Admin/UsersController
  -Se crea la vista edit.blade.php en resources/views/admin/users/ 
    -Se edita la vista admin/users/edit.blade.php
  -Se edita la función update de Admin/UsersController
    Nota: Rule::unique('users')->ignore(($user->id))
      -Es para que permita actualizar si el email es el mismo que el del usuario logueado
    Nota: Importar el namespace use Illuminate\Validation\Rule;
    Nota: >withFlash('Usuario actualizado')
      -Dónde withFlash es un método mágico de laravel que une la función with con la variable de sesión flash que es pasada a la vista
Commit - Editar contraseña
  -Se edita la vista admin/users/edit.blade.php
  -Se edita la función update de Admin/UsersController
    Nota: $request->filled('password')
      -Dónde filled pregunta si el elemento html password contiene información
  -Se crea una función mutador llamada setPasswordAttribute() en el modelo User para encriptar el campo password
  -Se edita la función create de Auth/RegisterController
    -Se quita el campo 'password' => bcrypt($data['password']), para evitar doble encriptación solo si se usa RegisterController para registrar
  -Se crea el formRequest UpdateUserRequest usando el comando
    -php artisan make:request UpdateUserRequest
    -Se edita el UpdateUserRequest
      -En la función authorize se devuelve true
      -Se importa el namespace use Illuminate\Validation\Rule;
      Nota: ->ignore($this->route('user')->id)
        Nota: route('user')->id
          -Dónde 'user' nos devuelve el usuario completo y solo obtenemos el id del objeto usuario
  -Se edita Admin/UsersController
    -Se quita el namespace use Illuminate\Validation\Rule; en Admin/UsersController
    -Se importa el namespace use App\Http\Requests\UpdateUserRequest; en Admin/UsersController
Commit - Agregar y quitar roles de usuario
  -Se edita la vista admin/users/edit.blade.php
    -Se crea la 2da columna col-md-6
  -Se edita la función edit de Admin/UsersController
    Nota: Se importa el modelo Role 
      -use Spatie\Permission\Models\Role;
  -Se crea el controlador Admin/UsersRolesController usando el comando
    -php artisan make:controller Admin/UsersRolesController -r
      -Dónde -r es para que cree los 7 método REST (index, create, store, show, edit, update y destroy) en el controlador
  -Se crea la ruta en web.php
    -Route::put('users/{user}/roles', 'UsersRolesController@update')->name('admin.users.roles.update');
  -Se edita la función edit de Admin/UsersRolesController
    Nota: Importar el modelo use App\User;
    Nota: $user->syncRoles($request->roles);
      -Dónde syncRoles es un método del paquete laravel-permission
    Nota: ->withFlash('Los roles han sido actualizados');
      -Dónde withFlash es un método mágico de laravel usando el método with con la variable de sesion flash pasada a la vista
    -Se borran todo los métodos excepto el método update ya que no se van a usar
Commit - Agregar y quitar permisos de usuarios 
  -Se edila la vista admin/users/edit.blade.php
  -Se edita la función edit de Admin/UsersController
    Nota: Importar el modelo Permission 
      -use Spatie\Permission\Models\Permission;
  -Se crea la ruta para los permisos en web.php
    -Route::put('users/{user}/permissions', 'UsersPermissionsController@update')->name('admin.users.permissions.update');
  -Se crea el controlador Admin/UsersPermissionsController
    -Se crea y edita la función update
      Nota: Importar el modelo User
        -use App\User;
        Nota: $user->syncPermissions($request->permissions);
      -Dónde syncPermissions es un método del paquete laravel-permission
    Nota: ->withFlash('Los permisos han sido actualizados');
      -Dónde withFlash es un método mágico de laravel usando el método with con la variable de sesion flash pasada a la vista
    NOTA: En el curso hubo un error al intentar guardar los permisos sin ningún permiso seleccionado, implementé la solución como en el curso
          pero en mi proyecto yo no tuve ese error
  -Se edita la función update de Admin/UsersRolesController
     NOTA: En el curso hubo un error al intentar guardar los roles sin ningún role seleccionado, implementé la solución como en el curso
          pero en mi proyecto yo no tuve ese error
Commit - Activando rutas anidadas
  -Se edita la función edit de Admin/UsersController
  -Se edita la vista admin/users/edit.blade.php
  -Se edita la vista admin/partials/nav.blade.php
  -Se edita la función create de Admin/UsersController
  -Se crea la vista create.blade.php en resources/views/admin/users/
  Nota: Hay un error con datatables al ver todos los usuarios
    -Solución: En la tabla de usuarios faltaba una etiqueta th, el thead debe tener las mismas columnas que tbody
      -Se edita la vista admin/users/index.blade.php
        -Se agrega el th en el thead <th>Operaciones</th>
Commit - Crear usuarios
  -Se edita la vista admin/users/index.blade.php
  -Se edita la vista admin/users/create.blade.php
  -Se edita la vista admin/users/edit.blade.php
    -Se corta el foreach de los roles y se pasa a una vista partial y se reemplaza por @include('admin.roles.checkboxes')
  -Se crea carpeta roles en resources/views/admin/ y dentro la vista checkboxes.blade.php
    -Se pega el foreach de roles, cortado de la vista admin/users/edit.blade.php
  -Se crea carpeta permissions en resources/views/admin/ y dentro la vista checkboxes.blade.php
    -Se pega el foreach de permissions, cortado de la vista admin/users/edit.blade.php
  -Se edita la función create en Admin/UsersController
  -Se edita la función store en Admin/UsersController
    Nota: Importar el modelo User si es que no está importado 
      -use App\User;
    Nota: ->withFlash('El usuario ha sido creado')
      -Dónde withFlash es el método mágico de laravel uniendo el método with con la variable de sesión flash que es pasada a la vista
  Nota: Al momento de crear un usuario sin roles ni permisos en el curso dio un error, pero en mi proyecto no, pero igual hice los cambios 
        para continuar igual que el curso
Commit - Eventos y Listeners
  -Se edita la propiedad $listen del app/Providers/EventServiceProvider
  -Se usa el comando php artisan event:generate
    -genera los eventos basandose em lo que haya en la propiedad $listen en app/Providers/EventServiceProvider.php
  Nota: El comando genera 2 nuevas carpetas, Events y Listeners
  -Se edita el evento UserWasCreated
    -Se quita la función broadcastOn() ya que no se va a usar
    -Se quita el trait InteractsWithSockets
  -Se edita la función store para usar el evento UserWasCreated recien creado
    Nota: Importar el namespace
      -use App\Events\UserWasCreated;
    Nota: UserWasCreated::dispatch($user, $data['password']);
      -Dónde dispatch es para disparar el evento
      -Dónde $user es el modelo User
      -Dónde $data['password'] es la variable que contiene el request
  -Se edita __construct en Events/UserWasCreated.php
  -Se edita el listener Listeners/SendLoginCredentials.php
    -Se quita el constructor __construct que no se va a usar
    -Se edita la funcioón handle()
Commit - Enviar las credenciales vía email
  -Se edita la función handle() de SendLoginCredentials
  -Se usa el comando php artisan make:mail LoginCredentials -m emails.login-credentials
      -Dónde -m es para crear la vista del email
    -El comando crea:
      -La carpeta Mail en app/ y dentro el archivo LoginCredentials.php
      -La carpeta emails y dentro la vista login-credentials.blade.php
  -Se edita Mail/LoginCredentials.php
    -Se agregan 2 variables protected
      -public $user;
      -public $password;
    -Se edita el constructor __construct
      -Se le pasan 2 parámetros: $user y $passowrd
  -Se crea la ruta email para visualizar el email que será enviado
    -Acá va el password que mostrará el preview del email
    Nota: Se comenta esta ruta porque solo se usó para ver el diseño del email
  -Se edita la vista emails/login-credentials.blade.php
  -Se crea o se inicia sesión en mailtrap para probar el envío del email
    -Sitio mailtrap: https://mailtrap.io/
  -Se edita el archivo .env para agregar los datos de mailtrap
    Nota:Los datos los da mailtrap
    MAIL_DRIVER=smtp
    MAIL_HOST=smtp.mailtrap.io
    MAIL_PORT=2525
    MAIL_USERNAME=f342f5dfd159ca
    MAIL_PASSWORD=030e3333865c6d
    MAIL_ENCRYPTION=null
  -Se edita la función build de Mail/LoginCredentials
    -Esto: return $this->markdown('emails.login-credentials');
    -Por esto: return $this->markdown('emails.login-credentials')->subject('Tus credenciales de acceso a ' . config('app.name'));
Commit - Políticas de acceso a usuarios
  -Se crea la política usando el comando 
    -php artisan make:policy UserPolicy -m User
      -Dónde -m es para vincularlo con un modelo en este caso el modelo User
  -Se edita UserPolicy
    -Se crea y se edita la función before()
    -Se edita la función view()
    -Se edita la función create()
    -Se edita la función update()
  -Se registra la política en app/Providers/AuthServiceProvider en la propiedad $policies
    -'App\User' => 'App\Policies\UserPolicy',
  -Se crea la función queryScope scopeAllowed () en el modelo User
  -Se edita la función index de Admin/UsersController
  -Se crean los permisos en UsersTableSeeder
      $viewUsersPermission = Permission::create(['name' => 'View users']);
      $createUsersPermission = Permission::create(['name' => 'Create users']);
      $updateUsersPermission = Permission::create(['name' => 'Update users']);
      $deleteUsersPermission = Permission::create(['name' => 'Delete users']);
    -Edite el nombre de los usuarios creados(Cambio hecho por mi)
    -Se quita el método bcrypt ya que hay un mutador que encripta el campo password
  -Se usa el comando php artisan migrate:fresh --seed
  -Se edita el controlador Admin/UsersController
    -Se editan las funciones create, store, show, edit y update
Commit - Eliminar usuarios
  -Se edita la función destroy de Admin/UsersController
  -Se edita la función update de Admin/UsersController
  -Se edita la migración create_posts_table
  -Se usa el comando php artisan migrate:fresh --seed
  -Corregí un error en la función create de Admin/UsersController ya que no permitía crear un nuevo usuario
    -Se cambió esto: $this->authorize('create', $user);
    -Por esto: $this->authorize('create', New User);
Commit - Permisos para asignar roles
  -Se edita el archivo app/Http/kernel.php
    -Se agregan en la propiedad $routeMiddleware
      -'role' => \Spatie\Permission\Middlewares\RoleMiddleware::class,
      -'permission' => \Spatie\Permission\Middlewares\PermissionMiddleware::class,
  -Se edita web.php
    -Esto: Route::put('users/{user}/roles', 'UsersRolesController@update')->name('admin.users.roles.update');
    -Por esto: Route::middleware('role:Admin')->put('users/{user}/roles', 'UsersRolesController@update')->name('admin.users.roles.update');
  -Se edita UsersTableSeedes
    -$UpdateRolesPermission = Permission::create(['name' => 'Update roles']);
  -Se usa el comando php artisan migrate:fresh --seed
  -Se edita web.php
    -Esto: Route::put('users/{user}/permissions', 'UsersPermissionsController@update')->name('admin.users.permissions.update');
    -Por esto:
      -Route::middleware('role:Admin')->put('users/{user}/permissions', 'UsersPermissionsController@update')->name('admin.users.permissions.update');
  -Se edita la vista admin/users/edit.blade.php
    -Se usa la directiva @role que viene con el paquete laravel-permission
    -Se usa la directiva @permission que viene con el paquete laravel-permission
Commit - Mostrando el listado de roles
  -Se crea la ruta en web.php
    -Route::resource('roles', 'RolesController', ['as' => 'admin']);
  -Se crea el controlador RolesController usando el comando
    -php artisan mak:controller Admin/RolesController -r
      -Dónde -r es para crear los 7 métodos REST (index, create, store, show, edit, update y destroy)
  -Se edita la función index de Admin/RolesController
    Nota: Importar el modelo Role 
      -use Spatie\Permission\Models\Role;
  -Se crea y se edita la vista index.blade.php en admin/roles/
Commit - Formulario para crear roles 
  -Se edita la función create de Admin/RolesController
  -Se crea y se edita la vista create.blade.php en admin/roles/
    -Se corta el condicional @if() de los errores y se pega en otra vista
    -Se reemplaza por la directiva @include()
      -@include('partials.error-messages')
  -Se crea la vista partial error-messages.blade.php en resources/views/partials/
    -Se pega el contenido cortado de la vista admin/roles/create.blade.php
  -Se edita la vista admin/users/create.blade.php
    -Se quita el condicional if() para mostrar los errores
      -Se reemplaza por la directiva @include()
        -include('partials.error-messages')
  -Se edita la vista admin/users/edit.blade.php
    -Se quita el condicional if() para mostrar los errores
      -Se reemplaza por la directiva @include()
        -include('partials.error-messages')
  -Se edita la función store de Admin/RolesController
  -Se edita la vista permissions/checkboxes.blade.php
  -Se edita la vista admin/users/create.blade.php
  -Se edita la vista admin/users/edit.blade.php
Commit - Formulario para editar roles
  -Se edita la función edit de Admin/RolesController
  -Se crea y se edita la vista edit.blade.php en views/admin/roles/
  -Se edita la vista partial  admin/permissions/checkboxes.blade.php
  -Se edita la función store en Admin/RolesController
  -Se edita la función update de Admin/RolesController
  -Se edita la migración create_permission_tables
    -Se agrega el campo display_name en permissions y en roles
      -$table->string('display_name')->nullable();
      Nota:Esta migración es del paquete laravel-permission
  -Se usa el comando php artisan migrate:fresh --seed
  -Se edita la vista admin/layout.blade.php
  -Se crea la función getRoleDisplayNames(9 en el modelo User)
  -Se unifican los formularios de edit y create para solo usar uno
  -Se crea la vista form.blade.php en admin/roles/
    -Se usa la directiva include para reemplazar a los formularios de las vistas admin/roles/create.blade.php y admin/roles/edit.blade.php
  -Se edita la función store de Admin/RolesController
Commit - Mensajes de validación personalizados
  -Se edita la función update de Admin/RolesController para cambiar el mensaje de validación
  -Se edita la función store de Admin/RolesController para cambiar el mensaje de validación
  -Se crea un FormRequest usando el comando
    -php artisan make:request SaveRolesRequest
  -Se edita SaveRolesRequest
    -Se edita la función authorize()
      -Se devuelve true
    -Se edita la función rules()
    -Se crea la función messages()
    -Se reemplaza el Request por SaveRolesRequest en el parámetro de la función edit y update 
      Nota: Importar el Form Request  
        -use App\Http\Requests\SaveRolesRequest;
Commit - Eliminar roles
  -Se edita la función destroy de Admin/RolesController
  -Se edita la vista errors/403.blade.php
Commit - Políticas de acceso a roles
  -Se edita la vista admin/roles/index.blade.php
  -Se edita la ruta en web.php
    -Esto: Route::resource('roles', 'RolesController', ['as' => 'admin']);
    -Por esto: Route::resource('roles', 'RolesController', ['except' => 'show', 'as' => 'admin']);
  -Se edita Admin/RolesController
    -Se quita la función show ya que no se va a utilizar
  -Se crea la política RolePolicy usando el comando
    -php artisan make:policy RolePolicy -m Role
      -Dónde -m es para vincular la política con el modelo Role
    -Se edita el namespace use App\Role; ya que no es el que usa laravel-permission
      -Esto: use App\Role;
      -Por esto: use Spatie\Permission\Models\Role;
    -Se registra la política en la propiedad $policies en Providers/AuthServiceProvider.php
      -'Spatie\Permission\Models\Role' => 'App\Policies\RolePolicy',
    -Se editan las funciones view, create, update y delete de RolePolicy
  -Se editan las funciones index, create, store, edit, update y destroy de Admin/RolesController para agregar la política
  -Se edita el UsersTableSeeder para agregar los permisos para los roles
  -Se usa el comando php artisan migrate:fresh --seed